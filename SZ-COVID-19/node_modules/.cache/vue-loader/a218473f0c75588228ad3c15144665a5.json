{"remainingRequest":"/home/yujiahao/Downloads/visual_work/SZ-COVID-19/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/yujiahao/Downloads/visual_work/SZ-COVID-19/src/page/case/components/force.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/yujiahao/Downloads/visual_work/SZ-COVID-19/src/page/case/components/force.vue","mtime":1617781888091},{"path":"/home/yujiahao/Downloads/visual_work/SZ-COVID-19/node_modules/cache-loader/dist/cjs.js","mtime":1617788517390},{"path":"/home/yujiahao/Downloads/visual_work/SZ-COVID-19/node_modules/babel-loader/lib/index.js","mtime":1617788517170},{"path":"/home/yujiahao/Downloads/visual_work/SZ-COVID-19/node_modules/cache-loader/dist/cjs.js","mtime":1617788517390},{"path":"/home/yujiahao/Downloads/visual_work/SZ-COVID-19/node_modules/vue-loader/lib/index.js","mtime":1617788568833}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJwppbXBvcnQgKiBhcyBkM0Zpc2hleWUgZnJvbSAnZDMtZmlzaGV5ZScKaW1wb3J0IF8gZnJvbSAnbG9kYXNoJwppbXBvcnQgVHJhY2tKU09OIGZyb20gJ0AvZGF0YS90cmFjaycKaW1wb3J0IHByb3ZpbmNlIGZyb20gJ0AvZGF0YS9wcm92aW5jZScKLy8gaW1wb3J0IEJhciBmcm9tICcuL2JhcicKaW1wb3J0IFRyZWUgZnJvbSAnLi90cmVlJwppbXBvcnQgU2VjdGlvbiBmcm9tICdAL2NvbXBvbmVudHMvc2VjdGlvbicKaW1wb3J0IE5vRGF0YSBmcm9tICdAL2NvbXBvbmVudHMvbm9EYXRhJwppbXBvcnQgeyBpbml0RGF0YSwgY2FsY3VsYXRlTm9kZUFuZExpbmsgfSBmcm9tICcuLi9tZXRob2RzL2RhdGFQcm9jZXNzb3InCgpleHBvcnQgZGVmYXVsdCB7CiAgICBuYW1lOiAnRm9yY2UnLAogICAgY29tcG9uZW50czogewogICAgICAgIFNlY3Rpb24sCiAgICAgICAgLy8gQmFyLAogICAgICAgIE5vRGF0YSwKICAgICAgICBUcmVlLAogICAgfSwKICAgIGRhdGEoKSB7CiAgICAgICAgaW5pdERhdGEoKTsKICAgICAgICBjb25zdCBmaXNoZXllUmFkaXVzID0gODA7CiAgICAgICAgY29uc3QgdGltZVJhbmdlID0gZDMuZXh0ZW50KFRyYWNrSlNPTiwgZCA9PiB7CiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkLnJlYWxEYXRlKS5nZXRUaW1lKCkKICAgICAgICB9KTsKICAgICAgICB0aGlzLlRJTUVfUkFOR0UgPSBbLi4udGltZVJhbmdlXQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHRyZWVEYXRhOiBbXSwKICAgICAgICAgICAgZmlzaGV5ZVJhZGl1cywKICAgICAgICAgICAgZGVtaW5BcnI6IFtdLAogICAgICAgICAgICBjb2xvck9iajoge30sCiAgICAgICAgICAgIGRpc2JhbGVkOiBbXSwKICAgICAgICAgICAgZmlsdGVyT2JqOiB7fSwKICAgICAgICAgICAgdGltZVJhbmdlOiB0aW1lUmFuZ2UsCiAgICAgICAgICAgIGNhc2VEZXRhaWw6IFtdLAogICAgICAgICAgICBmaWx0ZXJDb25kaXRpb246IFtdLAogICAgICAgIH0KICAgIH0sCiAgICBtZXRob2RzOiB7CiAgICAgICAgZHJhZzogc2ltdWxhdGlvbiA9PiB7CiAgICAgICAgICAgIGNvbnN0IGRyYWdzdGFydGVkID0gZCA9PiB7CiAgICAgICAgICAgICAgICBpZiAoIWQzLmV2ZW50LmFjdGl2ZSkgc2ltdWxhdGlvbi5hbHBoYVRhcmdldCgwLjMpLnJlc3RhcnQoKTsKICAgICAgICAgICAgICAgIGQuZnggPSBkLng7CiAgICAgICAgICAgICAgICBkLmZ5ID0gZC55OwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCBkcmFnZ2VkID0gZCA9PiB7CiAgICAgICAgICAgICAgICBkLmZ4ID0gZDMuZXZlbnQueDsKICAgICAgICAgICAgICAgIGQuZnkgPSBkMy5ldmVudC55OwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCBkcmFnZW5kZWQgPSBkID0+IHsKICAgICAgICAgICAgICAgIGlmICghZDMuZXZlbnQuYWN0aXZlKSBzaW11bGF0aW9uLmFscGhhVGFyZ2V0KDApOwogICAgICAgICAgICAgICAgZC5meCA9IG51bGw7CiAgICAgICAgICAgICAgICBkLmZ5ID0gbnVsbDsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgcmV0dXJuIGQzLmRyYWcoKQogICAgICAgICAgICAgICAgLm9uKCJzdGFydCIsIGRyYWdzdGFydGVkKQogICAgICAgICAgICAgICAgLm9uKCJkcmFnIiwgZHJhZ2dlZCkKICAgICAgICAgICAgICAgIC5vbigiZW5kIiwgZHJhZ2VuZGVkKTsKICAgICAgICB9LAogICAgICAgIGluaXRDaGFydCgpIHsKICAgICAgICAgICAgY29uc3QgdXNlTGVuZ3RoID0gTWF0aC5taW4odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpIAoKICAgICAgICAgICAgZDMuc2VsZWN0KCcjY2hhcnQnKS5zZWxlY3QoJ3N2ZycpLnJlbW92ZSgpCiAgICAgICAgICAgIAogICAgICAgICAgICB0aGlzLnN2ZyA9IGQzLnNlbGVjdCgnI2NoYXJ0JykKICAgICAgICAgICAgICAgIC5hcHBlbmQoInN2ZyIpCiAgICAgICAgICAgICAgICAuYXR0cigidmlld0JveCIsIFswLCAwLCB1c2VMZW5ndGgsIHVzZUxlbmd0aF0pCiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB1c2VMZW5ndGgpCiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdXNlTGVuZ3RoKQogICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpCiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3VzZUxlbmd0aC8yfSwgJHt1c2VMZW5ndGgvMn0pYCkKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBkMy5zZWxlY3QoJyNjaGFydD5zdmcnKQogICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2RlZnMnKQogICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JhZGlhbEdyYWRpZW50JykKICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAncmFkaWFsJykKCiAgICAgICAgICAgICAgICBncmFkaWVudAogICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3N0b3AnKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvZmZzZXQnLCAnMCUnKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsICdzdG9wLWNvbG9yOiAjMWY0NjhiOycpCiAgICAgICAgICAgICAgICBncmFkaWVudAogICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3N0b3AnKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvZmZzZXQnLCAnMTAwJScpCiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgJ3N0b3AtY29sb3I6ICMwZTIyNDQ7JykKCiAgICAgICAgICAgICAgICB0aGlzLnN2ZwogICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpCiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgMCkKICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCAwKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgdGhpcy5mb3JjZVJhZGl1c1sxXSkKICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnY2lyY2xlLWJnJywgdHJ1ZSkKCiAgICAgICAgICAgICAgICB0aGlzLnN2ZwogICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKQogICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdmaXNoZXllLWJnJywgdHJ1ZSkKICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgdGhpcy5maXNoZXllUmFkaXVzKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkaXNwbGF5JywgJ25vbmUnKQoKICAgICAgICAgICAgdGhpcy5zZWxlY3REYXRhID0gVHJhY2tKU09OOwogICAgICAgICAgICB0aGlzLmluaXRUaW1lQ2lyY2xlKCk7CiAgICAgICAgICAgIHRoaXMuaW5pdERlbWlDaXJjbGUoKTsKICAgICAgICAgICAgdGhpcy5jcmVhdGVGb3JjZSgpOwoKICAgICAgICAgICAgLy8g6buY6K6k6YCJ5Lit56Gu6K+K5pe26Ze0CiAgICAgICAgICAgIHRoaXMuc3ZnLnNlbGVjdCgnZ1tkYXRhLXNvcnRLZXk9cXpEYXRlXScpCiAgICAgICAgICAgICAgICAuZGlzcGF0Y2goJ2NsaWNrJykKICAgICAgICB9LAogICAgICAgIGluaXRUaW1lQ2lyY2xlKHR5cGUpIHsKICAgICAgICAgICAgY29uc3QgZ2FwVGltZUFyciA9IF8uY2hhaW4oVHJhY2tKU09OKQogICAgICAgICAgICAgICAgLnJlZHVjZSgob2JqLCBkKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgb2JqW2QucmVhbERhdGVdID0gewogICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkLnJlYWxEYXRlLAogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb2JqW2QucmVhbERhdGVdID8gb2JqW2QucmVhbERhdGVdLnZhbHVlICsgMSA6IDEsCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7CiAgICAgICAgICAgICAgICB9LCB7fSkKICAgICAgICAgICAgICAgIC52YWx1ZXMoKQogICAgICAgICAgICAgICAgLm9yZGVyQnkoZCA9PiBuZXcgRGF0ZShkLm5hbWUpLmdldFRpbWUoKSkKICAgICAgICAgICAgICAgIC52YWx1ZSgpOwoKICAgICAgICAgICAgY29uc3Qgb25lRGF5ID0gMjQgKiAzNjAwICogMTAwMDsKICAgICAgICAgICAgY29uc3QgdGltZUFyciA9IFtdOwogICAgICAgICAgICBnYXBUaW1lQXJyLmZvckVhY2goKGQsIGkpID0+IHsKICAgICAgICAgICAgICAgIHRpbWVBcnIucHVzaChkKTsKICAgICAgICAgICAgICAgIGlmKGdhcFRpbWVBcnJbaSsxXSkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVJdGVtQXJyID0gW2QubmFtZSwgZ2FwVGltZUFycltpKzFdLm5hbWVdLm1hcChkMSA9PiBuZXcgRGF0ZShkMSkuZ2V0VGltZSgpKQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVTcGFjZSA9IHRpbWVJdGVtQXJyWzFdIC0gdGltZUl0ZW1BcnJbMF0gLSBvbmVEYXk7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF5Q291bnQgPSB0aW1lU3BhY2Uvb25lRGF5OwogICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPD0gZGF5Q291bnQ7IGkrKyl7CiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVBcnIucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuZXcgRGF0ZSh0aW1lSXRlbUFyclswXSArIGkgKiBvbmVEYXkpLnRvTG9jYWxlRGF0ZVN0cmluZygpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQudmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pCgogICAgICAgICAgICBjb25zdCBpc1FaRGF0ZSA9IHR5cGUgPT09ICdxekRhdGUnCgogICAgICAgICAgICBpZiAodHlwZSAmJiAhaXNRWkRhdGUpIHsKICAgICAgICAgICAgICAgIHRpbWVBcnIubGVuZ3RoID0gMAogICAgICAgICAgICAgICAgXy5jaGFpbihUcmFja0pTT04pCiAgICAgICAgICAgICAgICAgICAgLm1hcCh0eXBlKQogICAgICAgICAgICAgICAgICAgIC5jb3VudEJ5KCkKICAgICAgICAgICAgICAgICAgICAubWFwKChkLCBrKSA9PiAoewogICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrLAogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZCwKICAgICAgICAgICAgICAgICAgICAgICAgc29ydGtleTogdHlwZSwKICAgICAgICAgICAgICAgICAgICB9KSkKICAgICAgICAgICAgICAgICAgICAub3JkZXJCeSgnbmFtZScpCiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZCA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVBcnIucHVzaChkKQogICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgLnZhbHVlKCkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IGQzLmV4dGVudCh0aW1lQXJyLCBkID0+IGQudmFsdWUpOwogICAgICAgICAgICBjb25zdCBjb2xvciA9IGQzLnNjYWxlTGluZWFyKCkKICAgICAgICAgICAgICAgIC5kb21haW4oW21pbiwgbWF4IC8gMiwgbWF4XSkKICAgICAgICAgICAgICAgIC5yYW5nZShbJyMwMDk2ODgnLCAnI2ZmYzEwNycsICcjZmYwMDAwJ10pCgogICAgICAgICAgICBjb25zdCBwaWUgPSBkMy5waWUoKQogICAgICAgICAgICAgICAgLnBhZEFuZ2xlKDApCiAgICAgICAgICAgICAgICAuc29ydChudWxsKQogICAgICAgICAgICAgICAgLnZhbHVlKGQgPT4gdHlwZSAmJiAhaXNRWkRhdGUgPyBkLnZhbHVlIDogMSkKCiAgICAgICAgICAgIGNvbnN0IGFyYyA9IGQzLmFyYygpCiAgICAgICAgICAgICAgICAuaW5uZXJSYWRpdXModGhpcy50aW1lUmFkaXVzWzBdKQogICAgICAgICAgICAgICAgLm91dGVyUmFkaXVzKHRoaXMudGltZVJhZGl1c1sxXSk7CgogICAgICAgICAgICBpZih0eXBlKSB7CiAgICAgICAgICAgICAgICBwaWUucGFkQW5nbGUoMC4wMSkKICAgICAgICAgICAgICAgIC8vIGFyYy5jb3JuZXJSYWRpdXMoMTApCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNvbnN0IGFyY3MgPSBwaWUodGltZUFycik7CgogICAgICAgICAgICB0aGlzLnN2Zy5zZWxlY3QoJ2cudGltZUxpbmUnKS5yZW1vdmUoKQoKICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5zdmcuYXBwZW5kKCdnJykKICAgICAgICAgICAgICAgIC5jbGFzc2VkKCd0aW1lTGluZScsIHRydWUpOwogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzCgogICAgICAgICAgICBjb25zdCBhcmNHID0gY29udGFpbmVyCiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdnLnRpbWVsaW5lQXJjJykKICAgICAgICAgICAgICAgIC5kYXRhKGFyY3MpCiAgICAgICAgICAgICAgICAuZW50ZXIoKQogICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpCiAgICAgICAgICAgICAgICAuY2xhc3NlZCgndGltZWxpbmVBcmMnLCB0cnVlKQogICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGUgfHwgaXNRWkRhdGUpIHJldHVybgogICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gZC5kYXRhOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyYyA9IGQzLnNlbGVjdCh0aGlzKQogICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCdwYXRoLm5vcm1hbCcpCiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJjQmlnZ2VyID0gZDMuc2VsZWN0KHRoaXMpCiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3BhdGguYmlnZ2VyJykKCiAgICAgICAgICAgICAgICAgICAgaWYoX3RoaXMuZmlsdGVyT2JqW3R5cGVdLmluY2x1ZGVzKG5hbWUpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGFyYy5jbGFzc2VkKCdhcmMtbm9uZScsIGZhbHNlKQogICAgICAgICAgICAgICAgICAgICAgICBhcmNCaWdnZXIuY2xhc3NlZCgnYXJjLW5vbmUnLCB0cnVlKQogICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maWx0ZXJPYmpbdHlwZV0gPSBfdGhpcy5maWx0ZXJPYmpbdHlwZV0uZmlsdGVyKGQgPT4gZCAhPT0gbmFtZSk7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgYXJjLmNsYXNzZWQoJ2FyYy1ub25lJywgdHJ1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgYXJjQmlnZ2VyLmNsYXNzZWQoJ2FyYy1ub25lJywgZmFsc2UpCiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbHRlck9ialt0eXBlXS5wdXNoKG5hbWUpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RUeXBlKCk7CiAgICAgICAgICAgICAgICB9KQoKICAgICAgICAgICAgYXJjRy5hcHBlbmQoJ3BhdGgnKQogICAgICAgICAgICAgICAgLmF0dHIoImZpbGwiLCBkID0+IHR5cGUgJiYgIWlzUVpEYXRlID8gICcjMTE2Y2Q1JyA6IGNvbG9yKGQuZGF0YS52YWx1ZSkpCiAgICAgICAgICAgICAgICAuYXR0cigiZCIsIGFyYykKICAgICAgICAgICAgICAgIC5hdHRyKCJzdHJva2UiLCAoKSA9PiB0eXBlID8gJyNhYWEnIDogJ25vbmUnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2N1cnNvcicsICgpID0+IHR5cGUgPyAncG9pbnRlcicgOiBudWxsKQogICAgICAgICAgICAgICAgLmNsYXNzZWQoJ25vcm1hbCcsIHRydWUpCiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpCiAgICAgICAgICAgICAgICAuZHVyYXRpb24oMzAwKQogICAgICAgICAgICAgICAgLmVhc2UoZDMuZWFzZUN1YmljSW4pCiAgICAgICAgICAgICAgICAuYXR0clR3ZWVuKCdkJyxmdW5jdGlvbihkKXsKICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gZDMuaW50ZXJwb2xhdGUoZC5zdGFydEFuZ2xlLGQuZW5kQW5nbGUpOwogICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KXsKICAgICAgICAgICAgICAgICAgICAgICAgZC5lbmRBbmdsZSAgID0gYSh0KTsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyYyhkKTsKICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgfSkKCiAgICAgICAgICAgIGNvbnN0IGFyY0JpZ2dlciA9IGQzLmFyYygpCiAgICAgICAgICAgICAgICAuaW5uZXJSYWRpdXModGhpcy50aW1lUmFkaXVzWzBdKQogICAgICAgICAgICAgICAgLm91dGVyUmFkaXVzKHRoaXMudGltZVJhZGl1c1sxXSArIDUpOwoKICAgICAgICAgICAgYXJjRy5hcHBlbmQoJ3BhdGgnKQogICAgICAgICAgICAgICAgLmF0dHIoImZpbGwiLCBkID0+IHR5cGUgPyAnIzExNmNkNScgOiBjb2xvcihkLmRhdGEudmFsdWUpKQogICAgICAgICAgICAgICAgLmF0dHIoImQiLCBhcmNCaWdnZXIpCiAgICAgICAgICAgICAgICAuYXR0cignY3Vyc29yJywgKCkgPT4gdHlwZSA/ICdwb2ludGVyJyA6IG51bGwpCiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnYmlnZ2VyJywgdHJ1ZSkKICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdhcmMtbm9uZScsIHRydWUpCgogICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXJjRy5hcHBlbmQoJ3RleHQnKQogICAgICAgICAgICAgICAgLmF0dHIoImR5IiwgIjAuMzVlbSIpCgogICAgICAgICAgICB0ZXh0LmFwcGVuZCgncGF0aCcpCiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJykKICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIGQgPT4gYGhpZGRlbkFyYyR7ZC5kYXRhLm5hbWV9YCkKICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZCA9PiB7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlfSA9IGQ7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2lubmVyUmFkaXVzLCBvdXRlclJhZGl1c10gPSB0aGlzLnRpbWVSYWRpdXM7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5nbGVzID0gW3N0YXJ0QW5nbGUsIGVuZEFuZ2xlXS5tYXAoZDEgPT4gZDEgLSBNYXRoLlBJIC8gMikKICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMpIC8gMjsKICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWRkbGVBbmdsZSA9IChhbmdsZXNbMV0gKyBhbmdsZXNbMF0pIC8gMgogICAgICAgICAgICAgICAgICAgIGNvbnN0IGludmVydERpcmVjdGlvbiA9IG1pZGRsZUFuZ2xlID4gMCAmJiBtaWRkbGVBbmdsZSA8IE1hdGguUEkKICAgICAgICAgICAgICAgICAgICBpZiAoaW52ZXJ0RGlyZWN0aW9uKSBhbmdsZXMucmV2ZXJzZSgpCiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGQzLnBhdGgoKQogICAgICAgICAgICAgICAgICAgIHBhdGguYXJjKDAsIDAsIHIsIGFuZ2xlc1swXSwgYW5nbGVzWzFdLCBpbnZlcnREaXJlY3Rpb24pCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgdGV4dC5hcHBlbmQoJ3RleHRQYXRoJykKICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKQogICAgICAgICAgICAgICAgLmF0dHIoJ3N0YXJ0T2Zmc2V0JywgJzUwJScpCiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJzlweCcpCiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICcjZmZmJykKICAgICAgICAgICAgICAgIC5hdHRyKCdocmVmJywgZCA9PiBgI2hpZGRlbkFyYyR7ZC5kYXRhLm5hbWV9YCkKICAgICAgICAgICAgICAgIC50ZXh0KGQgPT4gZC5kYXRhLm5hbWUucmVwbGFjZSgnMjAyMC8nLCAnJykpCiAgICAgICAgICAgICAgICAuYXR0cignZGlzcGxheScsIGZ1bmN0aW9uKGQpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoIH0gPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpCiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFkID0gZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZQogICAgICAgICAgICAgICAgICAgIGNvbnN0IFtpbm5lclJhZGl1c10gPSBfdGhpcy50aW1lUmFkaXVzOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbFdpZHRoID0gIGlubmVyUmFkaXVzICogcmFkCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUgJiYgd2lkdGggPj0gY2FsV2lkdGggPyAnbm9uZScgOiBudWxsCiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMudGltZVJhZGl1c1sxXSArICh0aGlzLmRlbWluUmFkaXVzWzBdIC0gdGhpcy50aW1lUmFkaXVzWzFdKSAvIDI7CgogICAgICAgICAgICBjb25zdCBpbmRleFNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKQogICAgICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIDFdKQogICAgICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgdGltZUFyci5sZW5ndGggLSAxXSk7CgogICAgICAgICAgICBmdW5jdGlvbiBkcmFnU3RhcnQoKXsKICAgICAgICAgICAgICAgIGxldCByYWQgPSBNYXRoLmF0YW4yKGQzLmV2ZW50LnksIGQzLmV2ZW50LngpOwogICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpCiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0cmFuc2Zvcm0nLCAoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSByYWRpdXMgKiBNYXRoLmNvcyhyYWQpOwogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gcmFkaXVzICogTWF0aC5zaW4ocmFkKTsKICAgICAgICAgICAgICAgICAgICAgICAgcmFkICs9IE1hdGguUEkgLyAyOwogICAgICAgICAgICAgICAgICAgICAgICBpZihyYWQgPCAwKSAgcmFkID0gTWF0aC5QSSAqIDIgKyByYWQKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSByYWQgLyAoTWF0aC5QSSAqIDIpICogMzYwOwogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weCkgcm90YXRlKCR7c2NhbGV9ZGVnKWAKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICB9CgogICAgICAgICAgICBjb25zdCBkcmFnRW5kID0gKGluZGV4KSA9PiB7CiAgICAgICAgICAgICAgICBsZXQgcmFkID0gTWF0aC5hdGFuMihkMy5ldmVudC55LCBkMy5ldmVudC54KTsKICAgICAgICAgICAgICAgIHJhZCArPSBNYXRoLlBJIC8gMjsKICAgICAgICAgICAgICAgIGlmKHJhZCA8IDApICByYWQgPSBNYXRoLlBJICogMiArIHJhZAogICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSByYWQgLyAoTWF0aC5QSSAqIDIpOwogICAgICAgICAgICAgICAgLy8gY29uc3QgdGltZUluZGV4ID0gTWF0aC5jZWlsKGluZGV4U2NhbGUoc2NhbGUpKTsKICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVJbmRleCA9IHBhcnNlSW50KGluZGV4U2NhbGUoc2NhbGUpKTsKICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVJdGVtID0gbmV3IERhdGUodGltZUFyclt0aW1lSW5kZXhdLm5hbWUpLmdldFRpbWUoKTsKICAgICAgICAgICAgICAgIC8vIGlmKHRpbWVJdGVtIDw9IHRoaXMudGltZVJhbmdlWzBdKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggPSAwCiAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYodGltZUl0ZW0gPj0gdGhpcy50aW1lUmFuZ2VbMV0pIHsKICAgICAgICAgICAgICAgICAgICAvLyBpbmRleCA9IDE7CiAgICAgICAgICAgICAgICAvLyB9CiAgICAgICAgICAgICAgICB0aGlzLnRpbWVSYW5nZVtpbmRleF0gPSB0aW1lSXRlbTsKICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0VHlwZSgpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKCdwb2x5Z29uJykKICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3llbGxvdycpCiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICcjZmZmJykKICAgICAgICAgICAgICAgIC5hdHRyKCdjdXJzb3InLCAncG9pbnRlcicpCiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgJzAsMTAgLTgsLTggOCwtOCcpCiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKCkgPT4gewogICAgICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7MH0sICR7cmFkaXVzICogTWF0aC5zaW4oIC0gTWF0aC5QSSAvIDIpfSlgCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCAoKSA9PiB0eXBlICYmICFpc1FaRGF0ZSA/ICdub25lJyA6IG51bGwpCiAgICAgICAgICAgICAgICAuY2FsbCgKICAgICAgICAgICAgICAgICAgICBkMy5kcmFnKCkKICAgICAgICAgICAgICAgICAgICAub24oImRyYWciLCBkcmFnU3RhcnQpCiAgICAgICAgICAgICAgICApCgogICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKCdwb2x5Z29uJykKICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3JlZCcpCiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICcjMTc3OGU4JykKICAgICAgICAgICAgICAgIC5hdHRyKCdjdXJzb3InLCAncG9pbnRlcicpCiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgJzAsMTAgLTgsLTggOCwtOCcpCiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKCkgPT4gewogICAgICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7MH0sICR7cmFkaXVzICogTWF0aC5zaW4oIC0gTWF0aC5QSSAvIDIpfSlgCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZSAmJiAhaXNRWkRhdGUgPyAnbm9uZScgOiBudWxsfSkKICAgICAgICAgICAgICAgIC5jYWxsKAogICAgICAgICAgICAgICAgICAgIGQzLmRyYWcoKQogICAgICAgICAgICAgICAgICAgIC5vbigiZHJhZyIsIGRyYWdTdGFydCkKICAgICAgICAgICAgICAgICAgICAub24oImVuZCIsICAoKSA9PiAgZHJhZ0VuZCgxKSkKICAgICAgICAgICAgICAgICkKICAgICAgICB9LAogICAgICAgIGluaXREZW1pQ2lyY2xlKCkgewogICAgICAgICAgICBjb25zdCBkZW1pbkFyciA9IFt7CiAgICAgICAgICAgICAgICBuYW1lOiAn5p+T55eF5Y6f5ZugJywKICAgICAgICAgICAgICAgIHNvcnRrZXk6ICdyZWFzb24nLAogICAgICAgICAgICB9LCB7CiAgICAgICAgICAgICAgICBuYW1lOiAn56Gu6K+K5pe26Ze0JywKICAgICAgICAgICAgICAgIHNvcnRrZXk6ICdxekRhdGUnLAogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBuYW1lOiAn5bm06b6EJywKICAgICAgICAgICAgICAgIHNvcnRrZXk6ICdubFJhbmdlJywKICAgICAgICAgICAgfSwgCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIG5hbWU6ICfmnaXmupDlnLAnLAogICAgICAgICAgICAgICAgc29ydGtleTogJ29yaWdpbicKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgbmFtZTogJ+eXheS+i+WFs+ezuycsCiAgICAgICAgICAgICAgICBzb3J0a2V5OiAncmVsYXRpb24nLAogICAgICAgICAgICB9XQoKICAgICAgICAgICAgZGVtaW5BcnIuZm9yRWFjaChkID0+IHsKICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyT2JqW2Quc29ydGtleV0gPSBbXTsKICAgICAgICAgICAgfSkKCiAgICAgICAgICAgIHRoaXMuZGVtaW5BcnIgPSBkZW1pbkFycgoKICAgICAgICAgICAgY29uc3QgZGVtaW5EYXRhID0gXy5jaGFpbihkZW1pbkFycikKICAgICAgICAgICAgICAgIC5tYXAoZCA9PiB7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZC5zb3J0a2V5OwogICAgICAgICAgICAgICAgICAgIGxldCB1c2VEYXRhID0gVHJhY2tKU09OOwogICAgICAgICAgICAgICAgICAgIGlmIChkLm5hbWUgPT09ICfmnaXmupDlnLAo5Zu95aSWKScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdXNlRGF0YSA9IFRyYWNrSlNPTi5maWx0ZXIoZDEgPT4gIXByb3ZpbmNlLmluY2x1ZGVzKGQxW2tleV0pKQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihkLm5hbWUgPT09ICfmnaXmupDlnLAo5Zu95YaFKScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdXNlRGF0YSA9IFRyYWNrSlNPTi5maWx0ZXIoZDEgPT4gcHJvdmluY2UuaW5jbHVkZXMoZDFba2V5XSkpCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbWluRGV0YWlsQXJyID0gXy5jaGFpbih1c2VEYXRhKQogICAgICAgICAgICAgICAgICAgICAgICAubWFwKGtleSkKICAgICAgICAgICAgICAgICAgICAgICAgLnVuaXEoKQogICAgICAgICAgICAgICAgICAgICAgICAubWFwKGQxID0+ICh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkMSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGQubmFtZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRrZXk6IGtleSwKICAgICAgICAgICAgICAgICAgICAgICAgfSkpCiAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZSgpOwoKICAgICAgICAgICAgICAgICAgICBpZihrZXkgPT09ICdubFJhbmdlJykgewogICAgICAgICAgICAgICAgICAgICAgICBkZW1pbkRldGFpbEFyci5zb3J0KChhLCBiKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBbYSwgYl0ubWFwKGQxID0+IE51bWJlcihkMS5uYW1lLnNwbGl0KCd+JylbMF0pKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJbMF0gLSBhcnJbMV07CiAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiBkZW1pbkRldGFpbEFycjsKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAuZmxhdHRlbigpCiAgICAgICAgICAgICAgICAudmFsdWUoKQoKICAgICAgICAgICAgdGhpcy5mb3JpZ25PcmlnaW4gPSBkZW1pbkRhdGEuZmlsdGVyKGQgPT4gZC50eXBlID09PSAi5p2l5rqQ5ZywKOWbveWklikiKQogICAgICAgICAgICAgICAgLm1hcChkID0+IGQubmFtZSkKCiAgICAgICAgICAgIGNvbnN0IHBpZSA9IGQzLnBpZSgpCiAgICAgICAgICAgICAgICAucGFkQW5nbGUoLjAwNSkKICAgICAgICAgICAgICAgIC5zb3J0KG51bGwpCiAgICAgICAgICAgICAgICAudmFsdWUoZCA9PiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKFsnb3JpZ2luJ10uaW5jbHVkZXMoZC5zb3J0a2V5KSkgcmV0dXJuIC44CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgICAgICAgIH0pCgogICAgICAgICAgICBjb25zdCBhcmMgPSBkMy5hcmMoKQogICAgICAgICAgICAgICAgLy8gLmNvcm5lclJhZGl1cygxMCkKICAgICAgICAgICAgICAgIC8vIC5wYWRBbmdsZSgwKQogICAgICAgICAgICAgICAgLmlubmVyUmFkaXVzKHRoaXMuZGVtaW5SYWRpdXNbMF0pCiAgICAgICAgICAgICAgICAub3V0ZXJSYWRpdXModGhpcy5kZW1pblJhZGl1c1sxXSk7CgogICAgICAgICAgICBjb25zdCBhcmNCaWdnZXIgPSBkMy5hcmMoKQogICAgICAgICAgICAgICAgLmlubmVyUmFkaXVzKHRoaXMuZGVtaW5SYWRpdXNbMF0pCiAgICAgICAgICAgICAgICAub3V0ZXJSYWRpdXModGhpcy5kZW1pblJhZGl1c1sxXSArIDUpOwoKICAgICAgICAgICAgY29uc3QgYXJjcyA9IHBpZShkZW1pbkFycik7CgogICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLnN2ZwogICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpCiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnc3VuQnVyc3QnLCB0cnVlKQoKICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzCgogICAgICAgICAgICBjb25zdCBhcmNHID0gY29udGFpbmVyCiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdnLnN1bkJ1cnN0QXJjJykKICAgICAgICAgICAgICAgIC5kYXRhKGFyY3MpCiAgICAgICAgICAgICAgICAuZW50ZXIoKQogICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpCiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnc3VuQnVyc3RBcmMnLCB0cnVlKQogICAgICAgICAgICAgICAgLmF0dHIoJ2RhdGEtc29ydEtleScsIGQgPT4gZC5kYXRhLnNvcnRrZXkpCiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHtzb3J0a2V5fSA9IGQuZGF0YTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmMgPSBkMy5zZWxlY3QodGhpcykKICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgncGF0aC5ub3JtYWwnKQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyY0JpZ2dlciA9IGQzLnNlbGVjdCh0aGlzKQogICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCdwYXRoLmJpZ2dlcicpCiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJjRyA9IGQzLnNlbGVjdCh0aGlzLnBhcmVudE5vZGUpCiAgICAgICAgICAgICAgICAgICAgaWYgKGFyY0JpZ2dlci5jbGFzc2VkKCdhcmMtbm9uZScpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGFyY0cuc2VsZWN0QWxsKCdwYXRoLm5vcm1hbCcpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnYXJjLW5vbmUnLCBmYWxzZSkKICAgICAgICAgICAgICAgICAgICAgICAgYXJjRy5zZWxlY3RBbGwoJ3BhdGguYmlnZ2VyJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdhcmMtbm9uZScsIHRydWUpCiAgICAgICAgICAgICAgICAgICAgICAgIGFyY0JpZ2dlci5jbGFzc2VkKCdhcmMtbm9uZScsIGZhbHNlKQogICAgICAgICAgICAgICAgICAgICAgICBhcmMuY2xhc3NlZCgnYXJjLW5vbmUnLCB0cnVlKQogICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbml0VGltZUNpcmNsZShzb3J0a2V5ID09PSAncXpEYXRlJyA/IHVuZGVmaW5lZCA6IHNvcnRrZXkpCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgYXJjRy5zZWxlY3RBbGwoJ3BhdGgubm9ybWFsJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdhcmMtbm9uZScsIGZhbHNlKQogICAgICAgICAgICAgICAgICAgICAgICBhcmNHLnNlbGVjdEFsbCgncGF0aC5iaWdnZXInKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2FyYy1ub25lJywgdHJ1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5pdFRpbWVDaXJjbGUoKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAvLyDph43nva7pgInmi6nnmoTml7bpl7TojIPlm7QKICAgICAgICAgICAgICAgICAgICBfdGhpcy50aW1lUmFuZ2UgPSBbLi4uX3RoaXMuVElNRV9SQU5HRV0KICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RUeXBlKCkKICAgICAgICAgICAgICAgIH0pCgoKICAgICAgICAgICAgYXJjRy5hcHBlbmQoJ3BhdGgnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnIzJmNTBhNScpCiAgICAgICAgICAgICAgICAuYXR0cigiZCIsIGFyYykKICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCdub25lJykKICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdub3JtYWwnLCB0cnVlKQogICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2FyYy1ub25lJywgZmFsc2UpCiAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgIGFyY0cuYXBwZW5kKCdwYXRoJykKICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJyMyZjUwYTUnKQogICAgICAgICAgICAgICAgLmF0dHIoImQiLCBhcmNCaWdnZXIpCiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywnbm9uZScpCiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnYmlnZ2VyJywgdHJ1ZSkKICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdhcmMtbm9uZScsIHRydWUpCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhcmNHLmFwcGVuZCgidGV4dCIpCiAgICAgICAgICAgICAgICAuYXR0cigiZHkiLCAiMC4zNWVtIikKCiAgICAgICAgICAgIHRleHQuYXBwZW5kKCdwYXRoJykKICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgZCA9PiBgaGlkZGVuQXJjJHtkLmRhdGEubmFtZX1fJHtkLmRhdGEudHlwZX1gKQogICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkID0+IHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGV9ID0gZDsKICAgICAgICAgICAgICAgICAgICBjb25zdCBbaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzXSA9IHRoaXMuZGVtaW5SYWRpdXM7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5nbGVzID0gW3N0YXJ0QW5nbGUsIGVuZEFuZ2xlXS5tYXAoZDEgPT4gZDEgLSBNYXRoLlBJIC8gMikKICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMpIC8gMjsKICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWRkbGVBbmdsZSA9IChhbmdsZXNbMV0gKyBhbmdsZXNbMF0pIC8gMgogICAgICAgICAgICAgICAgICAgIGNvbnN0IGludmVydERpcmVjdGlvbiA9IG1pZGRsZUFuZ2xlID4gMCAmJiBtaWRkbGVBbmdsZSA8IE1hdGguUEkKICAgICAgICAgICAgICAgICAgICAvLyBsZXQgaW52ZXJ0RGlyZWN0aW9uID0gJyc7CiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHR5cGVEaXJbZC5kYXRhLnR5cGVdKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGludmVydERpcmVjdGlvbiA9IHR5cGVEaXJbZC5kYXRhLnR5cGVdOwogICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGludmVydERpcmVjdGlvbiA9IG1pZGRsZUFuZ2xlID4gMCAmJiBtaWRkbGVBbmdsZSA8IE1hdGguUEkKICAgICAgICAgICAgICAgICAgICAvLyAgICAgdHlwZURpcltkLmRhdGEudHlwZV0gPSBpbnZlcnREaXJlY3Rpb247CiAgICAgICAgICAgICAgICAgICAgLy8gfQogICAgICAgICAgICAgICAgICAgIGlmIChpbnZlcnREaXJlY3Rpb24pIGFuZ2xlcy5yZXZlcnNlKCkKICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZDMucGF0aCgpCiAgICAgICAgICAgICAgICAgICAgcGF0aC5hcmMoMCwgMCwgciwgYW5nbGVzWzBdLCBhbmdsZXNbMV0sIGludmVydERpcmVjdGlvbikKICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC50b1N0cmluZygpCiAgICAgICAgICAgICAgICB9KQoKICAgICAgICAgICAgdGV4dC5hcHBlbmQoJ3RleHRQYXRoJykKICAgICAgICAgICAgICAgIC5hdHRyKCdzdGFydE9mZnNldCcsICc1MCUnKQogICAgICAgICAgICAgICAgLmF0dHIoJ2hyZWYnLCBkID0+IGAjaGlkZGVuQXJjJHtkLmRhdGEubmFtZX1fJHtkLmRhdGEudHlwZX1gKQogICAgICAgICAgICAgICAgLnRleHQoZCA9PiBkLmRhdGEubmFtZSk7CgogICAgICAgIH0sCiAgICAgICAgcHl0aGFnKHIsIGIsIGNvb3JkKSB7CiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMuZm9yY2VSYWRpdXNbMV07CiAgICAgICAgICAgIGNvbnN0IGh5cDIgPSBNYXRoLnBvdyhyYWRpdXMsIDIpOwogICAgICAgICAgICByICs9IDU7CiAgICAgICAgICAgIGIgPSBNYXRoLm1pbihyYWRpdXMgKiAyIC0gciwgTWF0aC5tYXgociwgYikpOwogICAgICAgICAgICB2YXIgYjIgPSBNYXRoLnBvdygKICAgICAgICAgICAgICAgIChiIC0gcmFkaXVzKSwgMgogICAgICAgICAgICApLAogICAgICAgICAgICBhID0gTWF0aC5zcXJ0KGh5cDIgLSBiMik7CiAgICAgICAgICAgIGNvb3JkID0gTWF0aC5tYXgoCiAgICAgICAgICAgICAgICByYWRpdXMgLSBhICsgciwKICAgICAgICAgICAgICAgIE1hdGgubWluKGEgKyByYWRpdXMgLSByLCBjb29yZCkKICAgICAgICAgICAgKTsKICAgICAgICAgICAgcmV0dXJuIGNvb3JkOwogICAgICAgIH0sCiAgICAgICAgY3JlYXRlRm9yY2UoKSB7CiAgICAgICAgICAgIHRoaXMuc2ltdWxhdGlvbiA9IGQzLmZvcmNlU2ltdWxhdGlvbigpCiAgICAgICAgICAgICAgICAuZm9yY2UoImxpbmsiLCBkMy5mb3JjZUxpbmsoKQogICAgICAgICAgICAgICAgICAgIC5pZChkID0+IGQuYmxoKQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgLmZvcmNlKCJjaGFyZ2UiLCAKICAgICAgICAgICAgICAgICAgICBkMy5mb3JjZU1hbnlCb2R5KCkuc3RyZW5ndGgoLTIwKQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgLmZvcmNlKCJ4IiwgZDMuZm9yY2VYKCkpCiAgICAgICAgICAgICAgICAuZm9yY2UoInkiLCBkMy5mb3JjZVkoKSkKICAgICAgICAgICAgICAgIC8vIC5mb3JjZSgnY2VudGVyJywgZDMuZm9yY2VDZW50ZXIoMCwgMCkpLy8g5ZCR5b+D5YqbCiAgICAgICAgICAgICAgICAvLyAuZm9yY2UoJ2NvbGxpZGUnLGQzLmZvcmNlQ29sbGlkZSgpICAvLyDlnIbnmoTnorDmkp7lipsKICAgICAgICAgICAgICAgIC8vICAgICAucmFkaXVzKDEwKSAgLy8g5qC55o2u5oyH5a6a55qE5Y2K5b6E5Yib5bu65LiA5Liq56Kw5pKe5Yqb44CC6buY6K6k5Li6IDEKICAgICAgICAgICAgICAgIC8vICkKICAgICAgICAgICAgICAgIC8vIC5mb3JjZSgncicsIGQzLmZvcmNlUmFkaWFsKAogICAgICAgICAgICAgICAgLy8gICAgICAgICB0aGlzLmZvcmNlUmFkaXVzWzFdLDAsMAogICAgICAgICAgICAgICAgLy8gICAgICkuc3RyZW5ndGgoLjUpKQogICAgICAgICAgICAgICAgLm9uKCJ0aWNrIiwgKCkgPT4gewogICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmNpcmNsZUcnKQogICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgZC54ID0gdGhpcy5weXRoYWcoZC5yLCBkLnksIGQueCk7IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZC55ID0gdGhpcy5weXRoYWcoZC5yLCBkLngsIGQueSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke2QueH0sICR7ZC55fSlgCiAgICAgICAgICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5saW5rSXRlbScpCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7ZC5zb3VyY2UueH0sICR7ZC5zb3VyY2UueX0pYAogICAgICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCdsaW5lJykKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoIngxIiwgMCkKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoInkxIiwgMCkKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoIngyIiwgZCA9PiBkLnRhcmdldC54IC0gZC5zb3VyY2UueCkKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoInkyIiwgZCA9PiBkLnRhcmdldC55IC0gZC5zb3VyY2UueSk7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcubGlua0l0ZW0nKQogICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JykKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R4JywgZCA9PiAoZC50YXJnZXQueCAtIGQuc291cmNlLngpIC8gMikKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgZCA9PiAoZC50YXJnZXQueSAtIGQuc291cmNlLnkpIC8gMikKICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgY29uc3QgZmlzaGV5ZSA9IGQzRmlzaGV5ZS5yYWRpYWwoKQogICAgICAgICAgICAgICAgLnJhZGl1cyh0aGlzLmZpc2hleWVSYWRpdXMpCiAgICAgICAgICAgICAgICAuZGlzdG9ydGlvbigyKQogICAgICAgICAgICAgICAgLnNtb290aGluZygwLjUpOwoKICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzCgogICAgICAgICAgICBjb25zdCBmb3JjZUNvbnRhaW5lciA9IHRoaXMuc3ZnLmFwcGVuZCgnZycpCiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnZm9yY2UnLCB0cnVlKQoKICAgICAgICAgICAgdGhpcy5zdmcub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgY29uc3QgbW91c2UgPSBkMy5tb3VzZSh0aGlzKTsKICAgICAgICAgICAgICAgIF90aGlzLnNpbXVsYXRpb24uc3RvcCgpCiAgICAgICAgICAgICAgICBmaXNoZXllLmZvY3VzKG1vdXNlKTsKICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmNpcmNsZUcnKS5lYWNoKGQgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBkLmZpc2hleWUgPSBmaXNoZXllKFtkLngsIGQueV0pOwogICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gYHRyYW5zbGF0ZSgke2QuZmlzaGV5ZVswXX0sICR7ZC5maXNoZXllWzFdfSlgKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgZCA9PiBkLmZpc2hleWVbMl0gPT09IDEgPyAnLjInIDogJzEnKQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuY2lyY2xlRycpCiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnY2lyY2xlJykKICAgICAgICAgICAgICAgICAgICAuYXR0cigncicsIGQgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gZC5maXNoZXllWzJdICogZC5yOwogICAgICAgICAgICAgICAgICAgICAgICBpZihyPjEyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTI7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIKICAgICAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5jaXJjbGVHJykKICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JykKICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgZCA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSAgZC5maXNoZXllWzJdICogNTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYocj45KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gOTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcgogICAgICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmxpbmtJdGVtJykKICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7ZC5zb3VyY2UuZmlzaGV5ZVswXX0sICR7ZC5zb3VyY2UuZmlzaGV5ZVsxXX0pYAogICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnbGluZScpCiAgICAgICAgICAgICAgICAgICAgLmF0dHIoIngxIiwgMCkKICAgICAgICAgICAgICAgICAgICAuYXR0cigieTEiLCAwKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCJ4MiIsIGQgPT4gZC50YXJnZXQuZmlzaGV5ZVswXSAtIGQuc291cmNlLmZpc2hleWVbMF0pCiAgICAgICAgICAgICAgICAgICAgLmF0dHIoInkyIiwgZCA9PiBkLnRhcmdldC5maXNoZXllWzFdIC0gZC5zb3VyY2UuZmlzaGV5ZVsxXSkKICAgICAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIGQgPT4gKGQudGFyZ2V0LmZpc2hleWVbMl0gPT09IDEgfHwgZC5zb3VyY2UuZmlzaGV5ZVsyXSA9PT0gMSkgPyAnLjInIDogJzEnKQoKICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmxpbmtJdGVtJykKICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JykKICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgZCA9PiBkLnNvdXJjZS5maXNoZXllWzJdICogNSkKICAgICAgICAgICAgICAgICAgICAuYXR0cignZHgnLCBkID0+IChkLnRhcmdldC5maXNoZXllWzBdIC0gZC5zb3VyY2UuZmlzaGV5ZVswXSkgLyAyKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsIGQgPT4gKGQudGFyZ2V0LmZpc2hleWVbMV0gLSBkLnNvdXJjZS5maXNoZXllWzFdKSAvIDIpCiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGF0YW4sIGFicywgUEl9ID0gTWF0aAogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbeDEsIHkxXSA9IGQuc291cmNlLmZpc2hleWUKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSBkLnRhcmdldC5maXNoZXllCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBhYnMoeDIgLSB4MSkKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IGFicyh5MiAtIHkxKQogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYWQgPSBhdGFuKHkgLyB4KQogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmcgPSAxODAgLyBQSSAqIHJhZAogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHJvdGF0ZSgke2FuZ30sICR7KHgyIC0geDEpIC8gMn0sICR7KHkyIC0geTEpIC8gMn0pYAogICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCBkID0+IGQudGFyZ2V0LmZpc2hleWVbMl0gPT09IDEgPyAnbm9uZScgOiBudWxsKQoKICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlUiA9IE1hdGguc3FydChtb3VzZS5yZWR1Y2UoKGMsIGQpID0+IGMgKyBNYXRoLnBvdyhkLCAyKSwgMCkpCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIC8vIOmxvOecvOiDjOaZrwogICAgICAgICAgICAgICAgY29uc3QgZmlzaGV5ZUJnID0gZDMuc2VsZWN0KCcuZmlzaGV5ZS1iZz5jaXJjbGUnKQogICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBtb3VzZVswXSkKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgbW91c2VbMV0pCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkaXNwbGF5JywgbnVsbCkKCiAgICAgICAgICAgICAgICAvLyDpvKDmoIfnp7vlh7rlkI7np7vpmaTmlYjmnpwKICAgICAgICAgICAgICAgIGlmIChtb3VzZVIgPiAoX3RoaXMuZm9yY2VSYWRpdXNbMV0pKSB7CiAgICAgICAgICAgICAgICAgICAgZmlzaGV5ZUJnLmF0dHIoJ2Rpc3BsYXknLCAnbm9uZScpCiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2ltdWxhdGlvbi5yZXN0YXJ0KCk7CgogICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmNpcmNsZUcnKQogICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBgdHJhbnNsYXRlKCR7ZC54fSwgJHtkLnl9KWApCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMSkKCiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuY2lyY2xlRycpCiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2NpcmNsZScpCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgZCA9PiBkLnIpOwoKICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5jaXJjbGVHJykKICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dCcpCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCA1KTsKCiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcubGlua0l0ZW0nKQogICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBgdHJhbnNsYXRlKCR7ZC5zb3VyY2UueH0sICR7ZC5zb3VyY2UueX0pYCkKICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnbGluZScpCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMSkKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoIngxIiwgMCkKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoInkxIiwgMCkKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoIngyIiwgZCA9PiBkLnRhcmdldC54IC0gZC5zb3VyY2UueCkKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoInkyIiwgZCA9PiBkLnRhcmdldC55IC0gZC5zb3VyY2UueSkKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5saW5rSXRlbScpCiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3RleHQnKQogICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgNSkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSkKCiAgICAgICAgICAgIHRoaXMubGlua0NvbnRhaW5lciA9IGZvcmNlQ29udGFpbmVyLmFwcGVuZCgnZycpLmNsYXNzZWQoJ2xpbmtzJywgdHJ1ZSk7CiAgICAgICAgICAgIHRoaXMubm9kZUNvbnRhaW5lciA9IGZvcmNlQ29udGFpbmVyLmFwcGVuZCgnZycpLmNsYXNzZWQoJ25vZGVzJywgdHJ1ZSk7CiAgICAgICAgfSwKICAgICAgICBkcmF3KCkgewogICAgICAgICAgICB0aGlzLnRyZWVEYXRhID0gW107CiAgICAgICAgICAgIHRoaXMuY2FsY3VhbHRlRGV0YWlsSW5mbygpOwogICAgICAgICAgICB0aGlzLmNhbGN1YWx0ZURldGFpbEluZm8oLTEpOwogICAgICAgICAgICBjb25zdCBbbm9kZXMsIGxpbmtzXSA9IGNhbGN1bGF0ZU5vZGVBbmRMaW5rKHRoaXMuc2VsZWN0RGF0YSk7CgogICAgICAgICAgICB0aGlzLnNpbXVsYXRpb24ubm9kZXMobm9kZXMpOwogICAgICAgICAgICB0aGlzLnNpbXVsYXRpb24uZm9yY2UoImxpbmsiKS5saW5rcyhsaW5rcyk7CgogICAgICAgICAgICBjb25zdCBsaW5rVXBkYXRlID0gdGhpcy5saW5rQ29udGFpbmVyCiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCIubGlua0l0ZW0iKQogICAgICAgICAgICAgICAgLmRhdGEobGlua3MsIGQgPT4gYCR7ZC5zb3VyY2UuYmxofV8ke2QudGFyZ2V0LmJsaH1gKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IGxpbmtHID0gbGlua1VwZGF0ZS5lbnRlcigpCiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJykKICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdsaW5rSXRlbScsIHRydWUpOwoKICAgICAgICAgICAgbGlua0cuYXBwZW5kKCJsaW5lIikKCiAgICAgICAgICAgIGxpbmtHLmFwcGVuZCgndGV4dCcpCiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgNSkKICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMCkKICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMCkKICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsIGQgPT4gKGQudGFyZ2V0LnggLSBkLnNvdXJjZS54KSAvIDIpCiAgICAgICAgICAgICAgICAuYXR0cignZHknLCBkID0+IChkLnRhcmdldC55IC0gZC5zb3VyY2UueSkgLyAyKQogICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCAnbm9uZScpCiAgICAgICAgICAgICAgICAudGV4dChkID0+IHsKICAgICAgICAgICAgICAgICAgICBsZXQgc2hvd1RleHQgPSBkLnRhcmdldC5ibGg7CiAgICAgICAgICAgICAgICAgICAgaWYoZC50YXJnZXQueXF0YmxneCkgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBibGhhcnIgPSBkLnRhcmdldC55cXRibGd4Lm1hdGNoKC8oXGQr44CBPykrL2cpWzBdOwogICAgICAgICAgICAgICAgICAgICAgICBzaG93VGV4dCA9IGQudGFyZ2V0LnlxdGJsZ3guc3BsaXQoYmxoYXJyKVsxXTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3dUZXh0CiAgICAgICAgICAgICAgICB9KQoKICAgICAgICAgICAgbGlua1VwZGF0ZS5leGl0KCkucmVtb3ZlKCk7CgogICAgICAgICAgICBjb25zdCBub2RlVXBkYXRlID0gdGhpcy5ub2RlQ29udGFpbmVyCiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCIuY2lyY2xlRyIpCiAgICAgICAgICAgICAgICAuZGF0YShub2RlcywgZCA9PiBkLmJsaCkKCiAgICAgICAgICAgIG5vZGVVcGRhdGUuc2VsZWN0KCdjaXJjbGUnKQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgZCA9PiBkLnIpCgogICAgICAgICAgICBjb25zdCBuZXdBZGROb2RlID0gbm9kZVVwZGF0ZS5lbnRlcigpCiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJykKICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdjaXJjbGVHJywgdHJ1ZSkKICAgICAgICAgICAgICAgIC5hdHRyKCdjdXJzb3InLCAncG9pbnRlcicpCiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpb25BcnIgPSBsaW5rcy5yZWR1Y2UoKGFyciwgZDEpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYoZDEuc291cmNlLmJsaCA9PT0gZC5ibGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGQxLnRhcmdldCkKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKCBkMS50YXJnZXQuYmxoID09PSBkLmJsaCApewogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goZDEuc291cmNlKQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgICAgICAgICAgICAgICAgfSwgW10pCiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZC5ibGgsCiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSwKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25BcnIuZm9yRWFjaChkID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxoYXJyID0gZC55cXRibGd4Lm1hdGNoKC8oXGQr44CBPykrL2cpWzBdOwogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG93VGV4dCA9IGQueXF0YmxneC5zcGxpdChibGhhcnIpWzFdOwogICAgICAgICAgICAgICAgICAgICAgICBvYmouY2hpbGRyZW4ucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHtkLmJsaH0oJHtzaG93VGV4dH0pYCwKICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZURhdGEgPSBvYmo7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjdWFsdGVEZXRhaWxJbmZvKGQpCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgLmNhbGwodGhpcy5kcmFnKHRoaXMuc2ltdWxhdGlvbikpCiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICAgICAgICB9KQoKICAgICAgICAgICAgbmV3QWRkTm9kZS5hcHBlbmQoImNpcmNsZSIpCiAgICAgICAgICAgICAgICAuYXR0cigncicsIGQgPT4gZC5yKQoKICAgICAgICAgICAgbmV3QWRkTm9kZS5hcHBlbmQoInRleHQiKQogICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIDUpCiAgICAgICAgICAgICAgICAudGV4dChkID0+IHsKICAgICAgICAgICAgICAgICAgICBsZXQgc2hvd1RleHQgPSBkLmJsaDsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvd1RleHQKICAgICAgICAgICAgICAgIH0pCgogICAgICAgICAgICBub2RlVXBkYXRlLmV4aXQoKS5yZW1vdmUoKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICB0aGlzLnNpbXVsYXRpb24uYWxwaGEoLjMpCiAgICAgICAgICAgICAgICAuYWxwaGFUYXJnZXQoMCkKICAgICAgICAgICAgICAgIC5yZXN0YXJ0KCk7CiAgICAgICAgfSwKICAgICAgICBzZWxlY3RUeXBlKCkgewogICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRpbWVSYW5nZS5tYXAoZCA9PiBuZXcgRGF0ZShkKS50b0xvY2FsZURhdGVTdHJpbmcoKSkpOwogICAgICAgICAgICB0aGlzLnNlbGVjdERhdGEgPSBUcmFja0pTT04uZmlsdGVyKGQgPT4gewogICAgICAgICAgICAgICAgbGV0IGlzS2VlcCA9IHRydWU7CiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmZpbHRlck9iaikKICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGtleSA9PiB0aGlzLmZpbHRlck9ialtrZXldLmxlbmd0aCA+IDApCiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgaXNLZWVwICYmIChpc0tlZXAgPSB0aGlzLmZpbHRlck9ialtrZXldLmluY2x1ZGVzKGRba2V5XSkpCiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIHJldHVybiBpc0tlZXA7CiAgICAgICAgICAgIH0pLmZpbHRlcihkID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVTdGFwID0gbmV3IERhdGUoZC5yZWFsRGF0ZSkuZ2V0VGltZSgpOwogICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVTdGFwID49IHRoaXMudGltZVJhbmdlWzBdICYmIHRpbWVTdGFwIDw9IHRoaXMudGltZVJhbmdlWzFdOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgY29uc3Qgc3RyZW5ndGhTY2FsZSA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFtUcmFja0pTT04ubGVuZ3RoLCAwXSkucmFuZ2UoWzE4LCA0MF0pCiAgICAgICAgICAgIGNvbnN0IGZvcmNlQ291bnQgPSBzdHJlbmd0aFNjYWxlKHRoaXMuc2VsZWN0RGF0YS5sZW5ndGgpOwogICAgICAgICAgICB0aGlzLnNpbXVsYXRpb24uZm9yY2UoImNoYXJnZSIsIAogICAgICAgICAgICAgICAgZDMuZm9yY2VNYW55Qm9keSgpLnN0cmVuZ3RoKC1mb3JjZUNvdW50KQogICAgICAgICAgICApCiAgICAgICAgICAgIHRoaXMuZHJhdygpOwogICAgICAgIH0sCiAgICAgICAgY2FsY3VhbHRlRGF0YSgpIHsKICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy4kcmVmcy5jaGFydC5vZmZzZXRIZWlnaHQ7CiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy4kcmVmcy5jaGFydC5vZmZzZXRXaWR0aDsKICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5taW4oaGVpZ2h0LCB3aWR0aCkgLyAyOwogICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7CiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0OwogICAgICAgICAgICB0aGlzLmZvcmNlUmFkaXVzID0gWzAsIHJhZGl1cyAtIDcwXTsKICAgICAgICAgICAgdGhpcy50aW1lUmFkaXVzID0gW3JhZGl1cyAtIDcwLCByYWRpdXMgLSA1MF0gOwogICAgICAgICAgICB0aGlzLmRlbWluUmFkaXVzID0gW3JhZGl1cyAtIDMwLCByYWRpdXMgLSAxMF07CiAgICAgICAgfSwKICAgICAgICBjYWxjdWFsdGVEZXRhaWxJbmZvKGQpIHsKICAgICAgICAgICAgbGV0IGluZm8gPSBbXTsKICAgICAgICAgICAgaWYoZCkgewogICAgICAgICAgICAgICAgY29uc3QgaW5jbHVkZSA9IFsnYmxoJywneGInLCAnbmwnLCAgJ2JrJywgJ2ZicnEnLCAncnlzaicsICdyYnl5JywgJ2J6enp5dGpkJ107CiAgICAgICAgICAgICAgICBjb25zdCBkZXNjT2JqID0gewogICAgICAgICAgICAgICAgICAgICJ5cXRibGd4IjogIuS4juWFtuS7lueXheS+i+WFs+ezuyIsCiAgICAgICAgICAgICAgICAgICAgInp3aHNqcWoiOiAi5Zyo5q2m5rGJ5pe26Ze0IiwKICAgICAgICAgICAgICAgICAgICAicmJ5eSI6ICLmn5Pnl4Xljp/lm6AiLAogICAgICAgICAgICAgICAgICAgICJienp6eXRqZCI6ICLlpIfms6giLAogICAgICAgICAgICAgICAgICAgICJiayI6ICLnl4XlhrUiLAogICAgICAgICAgICAgICAgICAgICJ4YiI6ICLmgKfliKsiLAogICAgICAgICAgICAgICAgICAgICJyeXNqIjogIuWFpemZouaXtumXtCIsCiAgICAgICAgICAgICAgICAgICAgImxzc2oiOiAi5p2l5rex5pe26Ze0IiwKICAgICAgICAgICAgICAgICAgICAiZmJpbmdzaiI6ICLlj5Hnl4Xml7bpl7QiLAogICAgICAgICAgICAgICAgICAgICJmYnJxIjogIuehruiviuaXpeacnyIsCiAgICAgICAgICAgICAgICAgICAgImp6ZCI6ICLlsYXkvY/lnLAiLAogICAgICAgICAgICAgICAgICAgICJmYnVzaiI6ICLlj5HluIPml7bpl7QiLAogICAgICAgICAgICAgICAgICAgICJubCI6ICLlubTpvoQiLAogICAgICAgICAgICAgICAgICAgICJibGgiOiAi55eF5L6L5Y+3IiwKICAgICAgICAgICAgICAgICAgICAibmF0aW9uYWxpdHkmbmF0aXZlIjoi5Zu957GN5ZKM57GN6LSv77yI5Zu95YaF5pyJ57GN6LSv6ICF6K6w5b2V57GN6LSv77yJIiwKICAgICAgICAgICAgICAgICAgICAidHJhY2siOiLpgJTlvoTlnLAiLAogICAgICAgICAgICAgICAgICAgICJ0cmFja190aW1lIjoi6YCU5b6E5Zyw55qE5pe26Ze0IiwKICAgICAgICAgICAgICAgICAgICAidHJhY2tfdHJhbnMiOiLpgJTlvoTkuqTpgJrlt6XlhbciLAogICAgICAgICAgICAgICAgICAgICJ0cmVhdG1lbnRfaG9zcGl0YWwiOiLmlZHmsrvljLvpmaIiCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpbmNsdWRlLmZvckVhY2goZDEgPT4gewogICAgICAgICAgICAgICAgICAgIGluZm8ucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogZGVzY09ialtkMV0sCiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkID09PSAtMSA/ICcnIDogZFtkMV0gfHwgJ+aaguaXoCcsCiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICB0aGlzLmNhc2VEZXRhaWwgPSBpbmZvCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJBcnIgPSBbXTsKICAgICAgICAgICAgICAgIGNvbnN0IGRlbWluQXJyID0gdGhpcy5kZW1pbkFyci5tYXAoZCA9PiAoewogICAgICAgICAgICAgICAgICAgIG5hbWU6IGQubmFtZSwKICAgICAgICAgICAgICAgICAgICBzb3J0a2V5OiBkLm5hbWUgPT09ICfmnaXmupDlnLAo5Zu95aSWKScgPyAnZm9yaWduT3JpZ2luJyA6IGQuc29ydGtleSwKICAgICAgICAgICAgICAgIH0pKQoKICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVSYW5nZSA9IHRoaXMudGltZVJhbmdlLmpvaW4oJ34nKSA9PT0gdGhpcy5USU1FX1JBTkdFLmpvaW4oJ34nKQogICAgICAgICAgICAgICAgICAgID8gW10KICAgICAgICAgICAgICAgICAgICA6IFt0aGlzLnRpbWVSYW5nZS5tYXAoZCA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgID0gbmV3IERhdGUoZCkKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2RhdGUuZ2V0RnVsbFllYXIoKX0vJHtkYXRlLmdldE1vbnRoKCkgKyAxfS8ke2RhdGUuZ2V0RGF0ZSgpfWAKICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbignficpXQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJPYmogPSB7CiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5maWx0ZXJPYmosCiAgICAgICAgICAgICAgICAgICAgcXpEYXRlOiBkYXRlUmFuZ2UsCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIF8uY2hhaW4oZmlsdGVyT2JqKQogICAgICAgICAgICAgICAgICAgIC5rZXlzKCkKICAgICAgICAgICAgICAgICAgICAuZm9ySW4oa2V5ID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQXJyLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZGVtaW5BcnIuZmluZChkID0+IGQuc29ydGtleSA9PT0ga2V5KS5uYW1lLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZpbHRlck9ialtrZXldLmpvaW4oJywgJykgfHwgJ+WFqOmDqCcsCiAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAudmFsdWUoKTsKICAgICAgICAgICAgICAgIGZpbHRlckFyci5wdXNoKHsKICAgICAgICAgICAgICAgICAgICBuYW1lOiAn55eF5L6L5pWw6YePJywKICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zZWxlY3REYXRhLmxlbmd0aCwKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckNvbmRpdGlvbiA9IGZpbHRlckFycjsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgaGFuZGxlUmVzZXQoKSB7CiAgICAgICAgICAgIGNvbnN0IGNoYXJ0Q29udGFpbmVyID0gZDMuc2VsZWN0KCcjY2hhcnQnKQogICAgICAgICAgICAgICAgLm9uKCdjbGljay5yZXNldCcsICgpID0+IHsKICAgICAgICAgICAgICAgICAgICBpZihkMy5ldmVudC50YXJnZXQgPT09IGNoYXJ0Q29udGFpbmVyCiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGQzLmV2ZW50LnRhcmdldCA9PT0gY2hhcnRDb250YWluZXIucXVlcnlTZWxlY3Rvcignc3ZnJykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGltZVJhbmdlID0gZDMuZXh0ZW50KFRyYWNrSlNPTiwgZCA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGQucmVhbERhdGUpLmdldFRpbWUoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRDaGFydCgpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFR5cGUoKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIC5ub2RlKCkKICAgICAgICB9LAogICAgfSwKICAgIG1vdW50ZWQoKSB7CiAgICAgICAgdGhpcy5jYWxjdWFsdGVEYXRhKCkKICAgICAgICB0aGlzLmluaXRDaGFydCgpOwogICAgICAgIHRoaXMuc2VsZWN0VHlwZSgpOwogICAgICAgIHRoaXMuaGFuZGxlUmVzZXQoKQogICAgfQp9Cg=="},{"version":3,"sources":["force.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"force.vue","sourceRoot":"src/page/case/components","sourcesContent":["<template>\n    <div class=\"forceCom\">\n        <div class=\"forceCom-left\">\n            <div class=\"filter\">\n                <Section title=\"筛选条件\">\n                    <div\n                        v-for=\"item in filterCondition\"\n                        class=\"filter-item\"\n                        :key=\"item.name\"\n                    >\n                        <span class=\"filter-item-name\">{{item.name}}</span>：\n                        <span class=\"filter-item-value\">{{item.value}}</span>\n                    </div>\n                </Section>\n            </div>\n            <div class=\"legend\">\n                <div class=\"legend-item\">\n                    <div class=\"legend-item-icon\">\n                        <div class=\"legend-link min\"></div>\n                    </div>\n                    <div class=\"legend-item-desc\">病例关系</div>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-item-icon\">\n                        <div class=\"legend-circle min\">0</div>\n                    </div>\n                    <div class=\"legend-item-desc\">病例个体，点击选择</div>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-item-icon\">\n                        <div class=\"legend-pointer\"></div>\n                    </div>\n                    <div class=\"legend-item-desc\">指针，可拨动</div>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-item-icon\">\n                        <div class=\"legend-filter-one min\">条件</div>\n                    </div>\n                    <div class=\"legend-item-desc\">一级筛选条件，点击选择</div>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-item-icon\">\n                        <div class=\"legend-time min\"></div>\n                    </div>\n                    <div class=\"legend-item-desc\">二级筛选条件(确诊时间)，拨动指针选择</div>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-item-icon\">\n                        <div class=\"legend-filter-two min\">条件</div>\n                    </div>\n                    <div class=\"legend-item-desc\">二级筛选条件(其他)，点击选择</div>\n                </div>\n            </div>\n        </div>\n        <div id=\"chart\" ref='chart'></div>\n        <div class=\"info\">\n            <Section title=\"病例信息\" class=\"infoData\">\n                <div v-if=\"caseDetail.length\"\n                    class=\"info-container\"\n                >\n                    <div\n                        v-for=\"item in caseDetail\"\n                        :key=\"item.key\"\n                        class=\"info-item\"\n                    >\n                    <span class=\"info-item-key\">{{item.key}}</span>：\n                    <span class=\"info-item-value\">{{item.value}}</span>\n                    </div>\n                </div>\n                <NoData v-else title=\"请选择病例\" />\n            </Section>\n            <Section title=\"选定病例关系\" class=\"treeData\" height=\"100%\">\n                <div class=\"tree-container\">\n                    <Tree :data=\"treeData\" />\n                </div>\n            </Section>\n        </div>\n    </div>\n    \n</template>\n\n<script>\n    import * as d3 from 'd3'\n    import * as d3Fisheye from 'd3-fisheye'\n    import _ from 'lodash'\n    import TrackJSON from '@/data/track'\n    import province from '@/data/province'\n    // import Bar from './bar'\n    import Tree from './tree'\n    import Section from '@/components/section'\n    import NoData from '@/components/noData'\n    import { initData, calculateNodeAndLink } from '../methods/dataProcessor'\n\n    export default {\n        name: 'Force',\n        components: {\n            Section,\n            // Bar,\n            NoData,\n            Tree,\n        },\n        data() {\n            initData();\n            const fisheyeRadius = 80;\n            const timeRange = d3.extent(TrackJSON, d => {\n                return new Date(d.realDate).getTime()\n            });\n            this.TIME_RANGE = [...timeRange]\n            return {\n                treeData: [],\n                fisheyeRadius,\n                deminArr: [],\n                colorObj: {},\n                disbaled: [],\n                filterObj: {},\n                timeRange: timeRange,\n                caseDetail: [],\n                filterCondition: [],\n            }\n        },\n        methods: {\n            drag: simulation => {\n                const dragstarted = d => {\n                    if (!d3.event.active) simulation.alphaTarget(0.3).restart();\n                    d.fx = d.x;\n                    d.fy = d.y;\n                }\n                \n                const dragged = d => {\n                    d.fx = d3.event.x;\n                    d.fy = d3.event.y;\n                }\n                \n                const dragended = d => {\n                    if (!d3.event.active) simulation.alphaTarget(0);\n                    d.fx = null;\n                    d.fy = null;\n                }\n                \n                return d3.drag()\n                    .on(\"start\", dragstarted)\n                    .on(\"drag\", dragged)\n                    .on(\"end\", dragended);\n            },\n            initChart() {\n                const useLength = Math.min(this.width, this.height) \n\n                d3.select('#chart').select('svg').remove()\n                \n                this.svg = d3.select('#chart')\n                    .append(\"svg\")\n                    .attr(\"viewBox\", [0, 0, useLength, useLength])\n                    .attr('width', useLength)\n                    .attr('height', useLength)\n                    .append('g')\n                    .attr('transform', `translate(${useLength/2}, ${useLength/2})`)\n                    \n                    const gradient = d3.select('#chart>svg')\n                        .append('defs')\n                        .append('radialGradient')\n                        .attr('id', 'radial')\n\n                    gradient\n                        .append('stop')\n                        .attr('offset', '0%')\n                        .attr('style', 'stop-color: #1f468b;')\n                    gradient\n                        .append('stop')\n                        .attr('offset', '100%')\n                        .attr('style', 'stop-color: #0e2244;')\n\n                    this.svg\n                        .append('circle')\n                        .attr('cx', 0)\n                        .attr('cy', 0)\n                        .attr('r', this.forceRadius[1])\n                        .classed('circle-bg', true)\n\n                    this.svg\n                        .append('g')\n                        .classed('fisheye-bg', true)\n                        .append('circle')\n                        .attr('r', this.fisheyeRadius)\n                        .attr('fill', 'none')\n                        .attr('display', 'none')\n\n                this.selectData = TrackJSON;\n                this.initTimeCircle();\n                this.initDemiCircle();\n                this.createForce();\n\n                // 默认选中确诊时间\n                this.svg.select('g[data-sortKey=qzDate]')\n                    .dispatch('click')\n            },\n            initTimeCircle(type) {\n                const gapTimeArr = _.chain(TrackJSON)\n                    .reduce((obj, d) => {\n                        obj[d.realDate] = {\n                            name: d.realDate,\n                            value: obj[d.realDate] ? obj[d.realDate].value + 1 : 1,\n                        }\n                        return obj;\n                    }, {})\n                    .values()\n                    .orderBy(d => new Date(d.name).getTime())\n                    .value();\n\n                const oneDay = 24 * 3600 * 1000;\n                const timeArr = [];\n                gapTimeArr.forEach((d, i) => {\n                    timeArr.push(d);\n                    if(gapTimeArr[i+1]) {\n                        const timeItemArr = [d.name, gapTimeArr[i+1].name].map(d1 => new Date(d1).getTime())\n                        const timeSpace = timeItemArr[1] - timeItemArr[0] - oneDay;\n                        const dayCount = timeSpace/oneDay;\n                        for(let i = 1; i <= dayCount; i++){\n                            timeArr.push({\n                                name: new Date(timeItemArr[0] + i * oneDay).toLocaleDateString(),\n                                value: d.value\n                            })\n                        }\n                    }\n                })\n\n                const isQZDate = type === 'qzDate'\n\n                if (type && !isQZDate) {\n                    timeArr.length = 0\n                    _.chain(TrackJSON)\n                        .map(type)\n                        .countBy()\n                        .map((d, k) => ({\n                            name: k,\n                            value: d,\n                            sortkey: type,\n                        }))\n                        .orderBy('name')\n                        .forEach(d => {\n                            timeArr.push(d)\n                        })\n                        .value()\n                }\n\n                const [min, max] = d3.extent(timeArr, d => d.value);\n                const color = d3.scaleLinear()\n                    .domain([min, max / 2, max])\n                    .range(['#009688', '#ffc107', '#ff0000'])\n\n                const pie = d3.pie()\n                    .padAngle(0)\n                    .sort(null)\n                    .value(d => type && !isQZDate ? d.value : 1)\n\n                const arc = d3.arc()\n                    .innerRadius(this.timeRadius[0])\n                    .outerRadius(this.timeRadius[1]);\n\n                if(type) {\n                    pie.padAngle(0.01)\n                    // arc.cornerRadius(10)\n                }\n\n                const arcs = pie(timeArr);\n\n                this.svg.select('g.timeLine').remove()\n\n                const container = this.svg.append('g')\n                    .classed('timeLine', true);\n                \n                const _this = this\n\n                const arcG = container\n                    .selectAll('g.timelineArc')\n                    .data(arcs)\n                    .enter()\n                    .append('g')\n                    .classed('timelineArc', true)\n                    .on('click', function(d) {\n                        if (!type || isQZDate) return\n                        const { name } = d.data;\n                        const arc = d3.select(this)\n                            .select('path.normal')\n                        const arcBigger = d3.select(this)\n                            .select('path.bigger')\n\n                        if(_this.filterObj[type].includes(name)) {\n                            arc.classed('arc-none', false)\n                            arcBigger.classed('arc-none', true)\n                            _this.filterObj[type] = _this.filterObj[type].filter(d => d !== name);\n                        } else {\n                            arc.classed('arc-none', true)\n                            arcBigger.classed('arc-none', false)\n                            _this.filterObj[type].push(name);\n                        }\n                        _this.selectType();\n                    })\n\n                arcG.append('path')\n                    .attr(\"fill\", d => type && !isQZDate ?  '#116cd5' : color(d.data.value))\n                    .attr(\"d\", arc)\n                    .attr(\"stroke\", () => type ? '#aaa' : 'none')\n                    .attr('cursor', () => type ? 'pointer' : null)\n                    .classed('normal', true)\n                    .transition()\n                    .duration(300)\n                    .ease(d3.easeCubicIn)\n                    .attrTween('d',function(d){\n                        const a = d3.interpolate(d.startAngle,d.endAngle);\n                        return function(t){\n                            d.endAngle   = a(t);\n                            return arc(d);\n                        };\n                    })\n\n                const arcBigger = d3.arc()\n                    .innerRadius(this.timeRadius[0])\n                    .outerRadius(this.timeRadius[1] + 5);\n\n                arcG.append('path')\n                    .attr(\"fill\", d => type ? '#116cd5' : color(d.data.value))\n                    .attr(\"d\", arcBigger)\n                    .attr('cursor', () => type ? 'pointer' : null)\n                    .classed('bigger', true)\n                    .classed('arc-none', true)\n\n                const text = arcG.append('text')\n                    .attr(\"dy\", \"0.35em\")\n\n                text.append('path')\n                    .attr('fill', 'none')\n                    .attr('id', d => `hiddenArc${d.data.name}`)\n                    .attr('d', d => {\n                        const {startAngle, endAngle} = d;\n                        const [innerRadius, outerRadius] = this.timeRadius;\n                        const angles = [startAngle, endAngle].map(d1 => d1 - Math.PI / 2)\n                        const r = (innerRadius + outerRadius) / 2;\n                        const middleAngle = (angles[1] + angles[0]) / 2\n                        const invertDirection = middleAngle > 0 && middleAngle < Math.PI\n                        if (invertDirection) angles.reverse()\n                        const path = d3.path()\n                        path.arc(0, 0, r, angles[0], angles[1], invertDirection)\n                        return path.toString()\n                    })\n                text.append('textPath')\n                    .attr('text-anchor', 'middle')\n                    .attr('startOffset', '50%')\n                    .attr('font-size', '9px')\n                    .attr('fill', '#fff')\n                    .attr('href', d => `#hiddenArc${d.data.name}`)\n                    .text(d => d.data.name.replace('2020/', ''))\n                    .attr('display', function(d) {\n                        const { width } = this.getBoundingClientRect()\n                        const rad = d.endAngle - d.startAngle\n                        const [innerRadius] = _this.timeRadius;\n                        const calWidth =  innerRadius * rad\n                        return type && width >= calWidth ? 'none' : null\n                    });\n\n                const radius = this.timeRadius[1] + (this.deminRadius[0] - this.timeRadius[1]) / 2;\n\n                const indexScale = d3.scaleLinear()\n                        .domain([0, 1])\n                        .range([0, timeArr.length - 1]);\n\n                function dragStart(){\n                    let rad = Math.atan2(d3.event.y, d3.event.x);\n                    d3.select(this)\n                        .style('transform', () => {\n                            const x = radius * Math.cos(rad);\n                            const y = radius * Math.sin(rad);\n                            rad += Math.PI / 2;\n                            if(rad < 0)  rad = Math.PI * 2 + rad\n                            const scale = rad / (Math.PI * 2) * 360;\n                            return `translate(${x}px, ${y}px) rotate(${scale}deg)`\n                        })\n                }\n\n                const dragEnd = (index) => {\n                    let rad = Math.atan2(d3.event.y, d3.event.x);\n                    rad += Math.PI / 2;\n                    if(rad < 0)  rad = Math.PI * 2 + rad\n                    const scale = rad / (Math.PI * 2);\n                    // const timeIndex = Math.ceil(indexScale(scale));\n                    const timeIndex = parseInt(indexScale(scale));\n                    const timeItem = new Date(timeArr[timeIndex].name).getTime();\n                    // if(timeItem <= this.timeRange[0]) {\n                        // index = 0\n                    // } else if(timeItem >= this.timeRange[1]) {\n                        // index = 1;\n                    // }\n                    this.timeRange[index] = timeItem;\n                    this.selectType();\n                }\n\n                container.append('polygon')\n                    .attr('fill', 'yellow')\n                    .attr('fill', '#fff')\n                    .attr('cursor', 'pointer')\n                    .attr('points', '0,10 -8,-8 8,-8')\n                    .attr('transform', () => {\n                        return `translate(${0}, ${radius * Math.sin( - Math.PI / 2)})`\n                    })\n                    .attr('display', () => type && !isQZDate ? 'none' : null)\n                    .call(\n                        d3.drag()\n                        .on(\"drag\", dragStart)\n                    )\n\n                container.append('polygon')\n                    .attr('fill', 'red')\n                    .attr('fill', '#1778e8')\n                    .attr('cursor', 'pointer')\n                    .attr('points', '0,10 -8,-8 8,-8')\n                    .attr('transform', () => {\n                        return `translate(${0}, ${radius * Math.sin( - Math.PI / 2)})`\n                    })\n                    .attr('display', function() {\n                        return type && !isQZDate ? 'none' : null})\n                    .call(\n                        d3.drag()\n                        .on(\"drag\", dragStart)\n                        .on(\"end\",  () =>  dragEnd(1))\n                    )\n            },\n            initDemiCircle() {\n                const deminArr = [{\n                    name: '染病原因',\n                    sortkey: 'reason',\n                }, {\n                    name: '确诊时间',\n                    sortkey: 'qzDate',\n                },\n                {\n                    name: '年龄',\n                    sortkey: 'nlRange',\n                }, \n                {\n                    name: '来源地',\n                    sortkey: 'origin'\n                },\n                {\n                    name: '病例关系',\n                    sortkey: 'relation',\n                }]\n\n                deminArr.forEach(d => {\n                    this.filterObj[d.sortkey] = [];\n                })\n\n                this.deminArr = deminArr\n\n                const deminData = _.chain(deminArr)\n                    .map(d => {\n                        const key = d.sortkey;\n                        let useData = TrackJSON;\n                        if (d.name === '来源地(国外)') {\n                            useData = TrackJSON.filter(d1 => !province.includes(d1[key]))\n                        } else if(d.name === '来源地(国内)') {\n                            useData = TrackJSON.filter(d1 => province.includes(d1[key]))\n                        }\n                        const deminDetailArr = _.chain(useData)\n                            .map(key)\n                            .uniq()\n                            .map(d1 => ({\n                                name: d1,\n                                type: d.name,\n                                sortkey: key,\n                            }))\n                            .value();\n\n                        if(key === 'nlRange') {\n                            deminDetailArr.sort((a, b) => {\n                                const arr = [a, b].map(d1 => Number(d1.name.split('~')[0]));\n                                return arr[0] - arr[1];\n                            })\n                        }\n                        return deminDetailArr;\n                    })\n                    .flatten()\n                    .value()\n\n                this.forignOrigin = deminData.filter(d => d.type === \"来源地(国外)\")\n                    .map(d => d.name)\n\n                const pie = d3.pie()\n                    .padAngle(.005)\n                    .sort(null)\n                    .value(d => {\n                        if (['origin'].includes(d.sortkey)) return .8\n                        return 1\n                    })\n\n                const arc = d3.arc()\n                    // .cornerRadius(10)\n                    // .padAngle(0)\n                    .innerRadius(this.deminRadius[0])\n                    .outerRadius(this.deminRadius[1]);\n\n                const arcBigger = d3.arc()\n                    .innerRadius(this.deminRadius[0])\n                    .outerRadius(this.deminRadius[1] + 5);\n\n                const arcs = pie(deminArr);\n\n                const container = this.svg\n                    .append('g')\n                    .classed('sunBurst', true)\n\n                const _this = this\n\n                const arcG = container\n                    .selectAll('g.sunBurstArc')\n                    .data(arcs)\n                    .enter()\n                    .append('g')\n                    .classed('sunBurstArc', true)\n                    .attr('data-sortKey', d => d.data.sortkey)\n                    .on('click', function(d) {\n                        const {sortkey} = d.data;\n                        const arc = d3.select(this)\n                            .select('path.normal')\n                        const arcBigger = d3.select(this)\n                            .select('path.bigger')\n                        const arcG = d3.select(this.parentNode)\n                        if (arcBigger.classed('arc-none')) {\n                            arcG.selectAll('path.normal')\n                                .classed('arc-none', false)\n                            arcG.selectAll('path.bigger')\n                                .classed('arc-none', true)\n                            arcBigger.classed('arc-none', false)\n                            arc.classed('arc-none', true)\n                            _this.initTimeCircle(sortkey === 'qzDate' ? undefined : sortkey)\n                        } else {\n                            arcG.selectAll('path.normal')\n                                .classed('arc-none', false)\n                            arcG.selectAll('path.bigger')\n                                .classed('arc-none', true)\n                            _this.initTimeCircle()\n                        }\n                        // 重置选择的时间范围\n                        _this.timeRange = [..._this.TIME_RANGE]\n                        _this.selectType()\n                    })\n\n\n                arcG.append('path')\n                    .attr('fill', '#2f50a5')\n                    .attr(\"d\", arc)\n                    .attr('stroke','none')\n                    .classed('normal', true)\n                    .classed('arc-none', false)\n                    \n\n                arcG.append('path')\n                    .attr('fill', '#2f50a5')\n                    .attr(\"d\", arcBigger)\n                    .attr('stroke','none')\n                    .classed('bigger', true)\n                    .classed('arc-none', true)\n                    \n                \n                const text = arcG.append(\"text\")\n                    .attr(\"dy\", \"0.35em\")\n\n                text.append('path')\n                    .attr('fill', 'none')\n                    .attr('id', d => `hiddenArc${d.data.name}_${d.data.type}`)\n                    .attr('d', d => {\n                        const {startAngle, endAngle} = d;\n                        const [innerRadius, outerRadius] = this.deminRadius;\n                        const angles = [startAngle, endAngle].map(d1 => d1 - Math.PI / 2)\n                        const r = (innerRadius + outerRadius) / 2;\n                        const middleAngle = (angles[1] + angles[0]) / 2\n                        const invertDirection = middleAngle > 0 && middleAngle < Math.PI\n                        // let invertDirection = '';\n                        // if (typeDir[d.data.type]) {\n                        //     invertDirection = typeDir[d.data.type];\n                        // } else {\n                        //     invertDirection = middleAngle > 0 && middleAngle < Math.PI\n                        //     typeDir[d.data.type] = invertDirection;\n                        // }\n                        if (invertDirection) angles.reverse()\n                        const path = d3.path()\n                        path.arc(0, 0, r, angles[0], angles[1], invertDirection)\n                        return path.toString()\n                    })\n\n                text.append('textPath')\n                    .attr('startOffset', '50%')\n                    .attr('href', d => `#hiddenArc${d.data.name}_${d.data.type}`)\n                    .text(d => d.data.name);\n\n            },\n            pythag(r, b, coord) {\n                const radius = this.forceRadius[1];\n                const hyp2 = Math.pow(radius, 2);\n                r += 5;\n                b = Math.min(radius * 2 - r, Math.max(r, b));\n                var b2 = Math.pow(\n                    (b - radius), 2\n                ),\n                a = Math.sqrt(hyp2 - b2);\n                coord = Math.max(\n                    radius - a + r,\n                    Math.min(a + radius - r, coord)\n                );\n                return coord;\n            },\n            createForce() {\n                this.simulation = d3.forceSimulation()\n                    .force(\"link\", d3.forceLink()\n                        .id(d => d.blh)\n                    )\n                    .force(\"charge\", \n                        d3.forceManyBody().strength(-20)\n                    )\n                    .force(\"x\", d3.forceX())\n                    .force(\"y\", d3.forceY())\n                    // .force('center', d3.forceCenter(0, 0))// 向心力\n                    // .force('collide',d3.forceCollide()  // 圆的碰撞力\n                    //     .radius(10)  // 根据指定的半径创建一个碰撞力。默认为 1\n                    // )\n                    // .force('r', d3.forceRadial(\n                    //         this.forceRadius[1],0,0\n                    //     ).strength(.5))\n                    .on(\"tick\", () => {\n                        d3.selectAll('.circleG')\n                            .attr('transform', d => {\n                                //  d.x = this.pythag(d.r, d.y, d.x); \n                                // d.y = this.pythag(d.r, d.x, d.y);\n                                return `translate(${d.x}, ${d.y})`\n                            });\n\n                        d3.selectAll('.linkItem')\n                            .attr('transform', d => {\n                                return `translate(${d.source.x}, ${d.source.y})`\n                            })\n                            .select('line')\n                            .attr(\"x1\", 0)\n                            .attr(\"y1\", 0)\n                            .attr(\"x2\", d => d.target.x - d.source.x)\n                            .attr(\"y2\", d => d.target.y - d.source.y);\n                        \n                        d3.selectAll('.linkItem')\n                            .select('text')\n                            .attr('dx', d => (d.target.x - d.source.x) / 2)\n                            .attr('dy', d => (d.target.y - d.source.y) / 2)\n                    });\n\n                const fisheye = d3Fisheye.radial()\n                    .radius(this.fisheyeRadius)\n                    .distortion(2)\n                    .smoothing(0.5);\n\n                const _this = this\n\n                const forceContainer = this.svg.append('g')\n                    .classed('force', true)\n\n                this.svg.on('mousemove', function() {\n                    const mouse = d3.mouse(this);\n                    _this.simulation.stop()\n                    fisheye.focus(mouse);\n                    d3.selectAll('.circleG').each(d => {\n                            d.fisheye = fisheye([d.x, d.y]);\n                        })\n                        .attr('transform', d => `translate(${d.fisheye[0]}, ${d.fisheye[1]})`)\n                        .attr('opacity', d => d.fisheye[2] === 1 ? '.2' : '1')\n                        \n                    d3.selectAll('.circleG')\n                        .select('circle')\n                        .attr('r', d => {\n                            const r = d.fisheye[2] * d.r;\n                            if(r>12) {\n                                return 12;\n                            }\n                            return r\n                        });\n\n                    d3.selectAll('.circleG')\n                        .select('text')\n                        .attr('font-size', d => {\n                            const r =  d.fisheye[2] * 5;\n                            if(r>9) {\n                                return 9;\n                            }\n                            return r\n                        });\n\n                    d3.selectAll('.linkItem')\n                        .attr('transform', d => {\n                            return `translate(${d.source.fisheye[0]}, ${d.source.fisheye[1]})`\n                        })\n                        .select('line')\n                        .attr(\"x1\", 0)\n                        .attr(\"y1\", 0)\n                        .attr(\"x2\", d => d.target.fisheye[0] - d.source.fisheye[0])\n                        .attr(\"y2\", d => d.target.fisheye[1] - d.source.fisheye[1])\n                        .attr('opacity', d => (d.target.fisheye[2] === 1 || d.source.fisheye[2] === 1) ? '.2' : '1')\n\n                    d3.selectAll('.linkItem')\n                        .select('text')\n                        .attr('font-size', d => d.source.fisheye[2] * 5)\n                        .attr('dx', d => (d.target.fisheye[0] - d.source.fisheye[0]) / 2)\n                        .attr('dy', d => (d.target.fisheye[1] - d.source.fisheye[1]) / 2)\n                        .attr('transform', d => {\n                            const { atan, abs, PI} = Math\n                            const [x1, y1] = d.source.fisheye\n                            const [x2, y2] = d.target.fisheye\n                            const x = abs(x2 - x1)\n                            const y = abs(y2 - y1)\n                            const rad = atan(y / x)\n                            const ang = 180 / PI * rad\n                            return `rotate(${ang}, ${(x2 - x1) / 2}, ${(y2 - y1) / 2})`\n                        })\n                        .attr('display', d => d.target.fisheye[2] === 1 ? 'none' : null)\n\n                    const mouseR = Math.sqrt(mouse.reduce((c, d) => c + Math.pow(d, 2), 0))\n                    \n                    // 鱼眼背景\n                    const fisheyeBg = d3.select('.fisheye-bg>circle')\n                            .attr('cx', mouse[0])\n                            .attr('cy', mouse[1])\n                            .attr('display', null)\n\n                    // 鼠标移出后移除效果\n                    if (mouseR > (_this.forceRadius[1])) {\n                        fisheyeBg.attr('display', 'none')\n                        _this.simulation.restart();\n\n                        d3.selectAll('.circleG')\n                            .attr('transform', d => `translate(${d.x}, ${d.y})`)\n                            .attr('opacity', 1)\n\n                        d3.selectAll('.circleG')\n                            .select('circle')\n                            .attr('r', d => d.r);\n\n                        d3.selectAll('.circleG')\n                            .select('text')\n                            .attr('font-size', 5);\n\n                        d3.selectAll('.linkItem')\n                            .attr('transform', d => `translate(${d.source.x}, ${d.source.y})`)\n                            .select('line')\n                            .attr('opacity', 1)\n                            .attr(\"x1\", 0)\n                            .attr(\"y1\", 0)\n                            .attr(\"x2\", d => d.target.x - d.source.x)\n                            .attr(\"y2\", d => d.target.y - d.source.y)\n                        \n                        d3.selectAll('.linkItem')\n                            .select('text')\n                            .attr('font-size', 5)\n                    }\n                })\n\n                this.linkContainer = forceContainer.append('g').classed('links', true);\n                this.nodeContainer = forceContainer.append('g').classed('nodes', true);\n            },\n            draw() {\n                this.treeData = [];\n                this.calcualteDetailInfo();\n                this.calcualteDetailInfo(-1);\n                const [nodes, links] = calculateNodeAndLink(this.selectData);\n\n                this.simulation.nodes(nodes);\n                this.simulation.force(\"link\").links(links);\n\n                const linkUpdate = this.linkContainer\n                    .selectAll(\".linkItem\")\n                    .data(links, d => `${d.source.blh}_${d.target.blh}`);\n                \n                const linkG = linkUpdate.enter()\n                    .append('g')\n                    .classed('linkItem', true);\n\n                linkG.append(\"line\")\n\n                linkG.append('text')\n                    .attr('font-size', 5)\n                    .attr('x', 0)\n                    .attr('y', 0)\n                    .attr('dx', d => (d.target.x - d.source.x) / 2)\n                    .attr('dy', d => (d.target.y - d.source.y) / 2)\n                    .attr('display', 'none')\n                    .text(d => {\n                        let showText = d.target.blh;\n                        if(d.target.yqtblgx) {\n                            const blharr = d.target.yqtblgx.match(/(\\d+、?)+/g)[0];\n                            showText = d.target.yqtblgx.split(blharr)[1];\n                        }\n                        return showText\n                    })\n\n                linkUpdate.exit().remove();\n\n                const nodeUpdate = this.nodeContainer\n                    .selectAll(\".circleG\")\n                    .data(nodes, d => d.blh)\n\n                nodeUpdate.select('circle')\n                        .attr('r', d => d.r)\n\n                const newAddNode = nodeUpdate.enter()\n                    .append('g')\n                    .classed('circleG', true)\n                    .attr('cursor', 'pointer')\n                    .on('click', d => {\n                        const relationArr = links.reduce((arr, d1) => {\n                            if(d1.source.blh === d.blh) {\n                                arr.push(d1.target)\n                            } else if( d1.target.blh === d.blh ){\n                                arr.push(d1.source)\n                            }\n                            return arr;\n                        }, [])\n                        var obj = {\n                            name: d.blh,\n                            children: [],\n                        }\n                        relationArr.forEach(d => {\n                            const blharr = d.yqtblgx.match(/(\\d+、?)+/g)[0];\n                            const showText = d.yqtblgx.split(blharr)[1];\n                            obj.children.push({\n                                name: `${d.blh}(${showText})`,\n                            })\n                        })\n                        this.treeData = obj;\n                        this.calcualteDetailInfo(d)\n                    })\n                    .call(this.drag(this.simulation))\n                    .on('mouseout', function() {\n                        d3.event.preventDefault()\n                        d3.event.stopImmediatePropagation()\n                        return false\n                    })\n\n                newAddNode.append(\"circle\")\n                    .attr('r', d => d.r)\n\n                newAddNode.append(\"text\")\n                    .attr('font-size', 5)\n                    .text(d => {\n                        let showText = d.blh;\n                        return showText\n                    })\n\n                nodeUpdate.exit().remove();\n                    \n                this.simulation.alpha(.3)\n                    .alphaTarget(0)\n                    .restart();\n            },\n            selectType() {\n                console.log(this.timeRange.map(d => new Date(d).toLocaleDateString()));\n                this.selectData = TrackJSON.filter(d => {\n                    let isKeep = true;\n                    Object.keys(this.filterObj)\n                        .filter(key => this.filterObj[key].length > 0)\n                        .forEach(key => {\n                            isKeep && (isKeep = this.filterObj[key].includes(d[key]))\n                        })\n                    return isKeep;\n                }).filter(d => {\n                    const timeStap = new Date(d.realDate).getTime();\n                    return timeStap >= this.timeRange[0] && timeStap <= this.timeRange[1];\n                });\n                const strengthScale = d3.scaleLinear().domain([TrackJSON.length, 0]).range([18, 40])\n                const forceCount = strengthScale(this.selectData.length);\n                this.simulation.force(\"charge\", \n                    d3.forceManyBody().strength(-forceCount)\n                )\n                this.draw();\n            },\n            calcualteData() {\n                const height = this.$refs.chart.offsetHeight;\n                const width = this.$refs.chart.offsetWidth;\n                const radius = Math.min(height, width) / 2;\n                this.width = width;\n                this.height = height;\n                this.forceRadius = [0, radius - 70];\n                this.timeRadius = [radius - 70, radius - 50] ;\n                this.deminRadius = [radius - 30, radius - 10];\n            },\n            calcualteDetailInfo(d) {\n                let info = [];\n                if(d) {\n                    const include = ['blh','xb', 'nl',  'bk', 'fbrq', 'rysj', 'rbyy', 'bzzzytjd'];\n                    const descObj = {\n                        \"yqtblgx\": \"与其他病例关系\",\n                        \"zwhsjqj\": \"在武汉时间\",\n                        \"rbyy\": \"染病原因\",\n                        \"bzzzytjd\": \"备注\",\n                        \"bk\": \"病况\",\n                        \"xb\": \"性别\",\n                        \"rysj\": \"入院时间\",\n                        \"lssj\": \"来深时间\",\n                        \"fbingsj\": \"发病时间\",\n                        \"fbrq\": \"确诊日期\",\n                        \"jzd\": \"居住地\",\n                        \"fbusj\": \"发布时间\",\n                        \"nl\": \"年龄\",\n                        \"blh\": \"病例号\",\n                        \"nationality&native\":\"国籍和籍贯（国内有籍贯者记录籍贯）\",\n                        \"track\":\"途径地\",\n                        \"track_time\":\"途径地的时间\",\n                        \"track_trans\":\"途径交通工具\",\n                        \"treatment_hospital\":\"救治医院\"\n                    }\n                    include.forEach(d1 => {\n                        info.push({\n                            key: descObj[d1],\n                            value: d === -1 ? '' : d[d1] || '暂无',\n                        })\n                    })\n                    this.caseDetail = info\n                } else {\n                    const filterArr = [];\n                    const deminArr = this.deminArr.map(d => ({\n                        name: d.name,\n                        sortkey: d.name === '来源地(国外)' ? 'forignOrigin' : d.sortkey,\n                    }))\n\n                    const dateRange = this.timeRange.join('~') === this.TIME_RANGE.join('~')\n                        ? []\n                        : [this.timeRange.map(d => {\n                            const date  = new Date(d)\n                            return `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`\n                            }).join('~')]\n                    \n                    const filterObj = {\n                        ...this.filterObj,\n                        qzDate: dateRange,\n                    }\n                    \n                    _.chain(filterObj)\n                        .keys()\n                        .forIn(key => {\n                            filterArr.push({\n                                name: deminArr.find(d => d.sortkey === key).name,\n                                value: filterObj[key].join(', ') || '全部',\n                            })\n                        })\n                        .value();\n                    filterArr.push({\n                        name: '病例数量',\n                        value: this.selectData.length,\n                    })\n                    this.filterCondition = filterArr;\n                }\n            },\n            handleReset() {\n                const chartContainer = d3.select('#chart')\n                    .on('click.reset', () => {\n                        if(d3.event.target === chartContainer\n                            || d3.event.target === chartContainer.querySelector('svg')) {\n                                this.timeRange = d3.extent(TrackJSON, d => {\n                                    return new Date(d.realDate).getTime()\n                                });\n                                this.initChart()\n                                this.selectType();\n                            }\n                    })\n                    .node()\n            },\n        },\n        mounted() {\n            this.calcualteData()\n            this.initChart();\n            this.selectType();\n            this.handleReset()\n        }\n    }\n</script>\n\n<style lang=\"less\">\n    .forceCom{\n        display: flex;\n        padding-top: 20px;\n        align-items: center;\n        height: 100%;\n        position: relative;\n    }\n    .forceCom-left {\n        display: flex;\n        justify-content: space-between;\n        flex-direction: column;\n        height: 100%;\n        width: 20%;\n    }\n    .filter {\n        width: 100%;\n        font-size: 14px;\n        .section {\n            width: 100%;\n            padding-bottom: 10px;\n            .section-body {\n                min-height: 150px;\n                width: 100%;\n                line-height: 2.5em;\n                display: flex;\n                justify-content: center;\n                flex-direction: column;\n            }\n        }\n        .filter-item {\n            width: 100%;\n            display: flex;\n            .filter-item-name{\n                text-align: right;\n                width: 80px;\n                font-size: 14px;\n            }\n            .filter-item-value{\n                flex: 1;\n            }\n        }\n    }\n    #chart{\n        width: 50%;\n        height: 100%;\n        min-width: 700px;\n        min-height: 700px;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n    }\n    .legend{\n        .legend-item{\n            display: flex;\n            align-items: center;\n            margin-top: 10px;\n            .legend-item-icon{\n                width: 40px;\n                text-align: center;\n                &>div{\n                    display: inline-block;\n                }\n                .legend-circle{\n                    height: 22px;\n                    width: 22px;\n                    line-height: 22px;\n                    text-align: center;\n                    border-radius: 40px;\n                    font-size: 12px;\n                    color: #fff;\n                    background: rgba(255, 0, 0, 0.45);\n                    border: solid 1px rgba(255, 255, 255, 0.5);\n                }\n                .legend-link{\n                    margin-bottom:3px;\n                    height: 1px;\n                    width: 40px;\n                    background: rgba(255, 0, 0, 0.45);\n                }\n                .legend-pointer{\n                    width: 0;\n                    height: 0;\n                    border: 8px solid transparent;\n                    border-top: 14px solid #1778e8;\n                    transform: translateY(6px);\n                }\n                .legend-time{\n                    height: 20px;\n                    width: 40px;\n                    background: linear-gradient(to right, #009688, #ffc107, #ff0000);\n                }\n                .min {\n                    transform: scale(.8)\n                }\n                .legend-filter-one{\n                    height: 20px;\n                    width: 40px;\n                    background: #2f50a5;   \n                }\n                .legend-filter-two{\n                    height: 20px;\n                    width: 40px;\n                    background: #116cd5;\n                    border: solid 1px #aaa;\n                }\n            }\n            .legend-item-desc{\n                margin-left: 10px;\n            }\n        }\n    }\n    .force{\n        circle {\n            stroke: #fff;\n            stroke: rgba(255, 255, 255, 0.5);\n            stroke-width: 1;\n            fill: #bf5658;\n            fill: rgba(255, 0, 0, 0.45);\n            cursor: pointer;\n        }\n        text{\n            fill: #fff;\n            text-anchor: middle;\n        }\n        .linkItem{\n            stroke: rgba(255, 0, 0, 0.45);\n            stroke-width: 1;\n            text{\n                stroke: #fff;\n                stroke-width: .2;\n            }\n        }\n    }\n\n    .timeLine {\n        .timelineArc {\n            transition: .3s;\n        }\n    }\n\n    .sunBurst {\n        .sunBurstArc {\n            transition: .3s;\n            &>path {\n                cursor: pointer;\n            }\n            &>text {\n                pointer-events: none;\n                text-anchor: middle;\n                user-select: none;\n                fill: #fff;\n            }\n        }\n    }\n\n    .info {\n        height: 100%;\n        flex: 1;\n        display: flex;\n        margin-left: 30px;\n        flex-direction: column;\n        justify-content: space-between;\n        .infoData{\n            height: 50%;\n        }\n        .info-container{\n            min-height: 200px;\n            display: flex;\n            height: 100%;\n            flex-direction: column;\n            justify-content: space-around;\n        }\n        .info-item{\n            height: 50%;\n            line-height: 30px;\n            display: flex;\n            .info-item-key{\n                display: inline-block;\n                width: 100px;\n                font-weight: bolder;\n                font-size: 14px;\n                text-align: right;\n            }\n            .info-item-value{\n                flex: 1;\n                white-space: pre-wrap;\n            }\n        }\n        .treeData {\n            height: 50%;\n            margin-bottom: 0;\n            .tree-container{\n                height: 100%;\n            }\n        }\n    }\n    .circle-bg {\n        fill:url(#radial)\n    }\n    .fisheye-bg>circle {\n        fill: #4f659b;\n        opacity: .3;\n    }\n    .arc-none {\n        display: none;\n    }\n</style>"]}]}